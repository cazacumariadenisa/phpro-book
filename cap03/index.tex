\chapter{Reutilizarea și modularizarea codului}

\begin{chapsummary}
Acest capitol îți va prezenta tehnici de reutilizare a codului,
ceea ce-ți va permite să programezi mai eficient. Îți va
mai deschide porțile și către mai toate funcționalitățile
și capacitățile limbajului PHP.
\end{chapsummary}

\section{Funcții}
\subsection{Funcții proprii. Termeni generali}
%retval, args, optional args, references, static variables
O funcție este ca o cutie neagră. O hrănești cu date prin
intermediul a ceea ce numim \textsl{parametri}, și ea
face anumite operații pe acel input primit prin parametri.

Unele funcții generează output, alte funcții returnează
valori și nu afișează nimic, iar altele nici nu acceptă
parametri.

Până acum am întâlnit o singură funcție, \texttt{var\_dump()}.
Ea acceptă un singur parametru,\footnote{Greșeală deliberată.
Voi reveni la lecția despre funcții variadice.} care trebuie să fie o expresie,
și generează ca output valoarea acelei expresii, alături de tipul
de date al expresiei.

Deoarece tipul de date al parametrului acceptat de această funcție
nu trebuie să fie de un anumit fel specific, ci poate avea 
de la două tipuri de date în sus,
spunem că parametrul funcției este de tipul \textsl{mixed}.
Acesta nu este un tip de date existent în PHP, este doar
felul în care putem documenta astfel de valori care pot
avea tipuri de date multiple.

Documentarea funcției var\_dump() ar putea arăta deci astfel:

\begin{verbatim}
void var_dump(mixed $expression)
  - dumps information about an expression
\end{verbatim}

\texttt{var\_dump} se numește \textsl{identificatorul} sau numele funcției.
Acel \texttt{void} din fața lui ne spune ce fel de date returnează funcția. \textsl{void}
este un alt tip de date care de fapt nu există și este folosit doar în documentarea
funcțiilor. \textit{void} înseamnă nimic, deci în cazul nostru, înseamnă că
funcția nu returnează nimic.

Dar cum creăm propriile funcții? Hai să creăm o funcție care nu acceptă nici un
parametru, care nu returnează nimic, dar care doar face ceva. Hai să îi dăm acestei
funcții identificatorul \texttt{foo}. Documentarea ei va arăta deci astfel:
\begin{verbatim}
void foo(void)
\end{verbatim}
Această "documentare" se numește și \textsl{semnătura funcției}, deoarece
ne spune cum arată din exterior acea funcție, ce fel de parametri acceptă
și în ce ordine, și ce fel de date returnează.

Limbajul PHP nu este at\^at de strict \^in privința tipurilor de date
acceptate ca parametri sau tipurilor de date returnate de funcții. De aceea
documentarea semnăturilor funcțiilor noastre ne poate feri pe noi \^inșine
de greșeli de programare. De exemplu, dacă documentăm o funcție ca return\^and
``int'', și la un moment dat, \^in timp ce implementăm acea funcție,
returnăm un ``string'', atunci e clar că am făcut o greșeală, și cel
mai probabil greșeala este \^in implementație.

\good{Atunci c\^and decizi să creezi o funcție, mai \^int\^ai analizează logistica
care impune necesitatea acelei funcții, documentează de ce există acea funcție, ce face,
și semnătura sa. După aceea implementează funcția astfel \^inc\^at să respecte
documentația sa.}




Pe lângă o semnătură, o funcție mai are și o implementație. Toate funcțiile
trebuie implementate înainte de a fi folosite. Pentru a declara
implementația unei funcții în PHP,\footnote{Sau pe scurt: \textit{pentru
a implementa o funcție}}
scriem cuvântul cheie \texttt{function} urmat de identificatorul funcției,
paranteze rotunde, și între ele o listă a eventualilor parametri,
apoi implementația efectivă a funcției între acolade, ca un bloc
de instrucțiuni. Funcția
noastră \texttt{foo} ar putea avea următoarea implementație:
\begin{lstlisting}
<?php
function foo() {
  echo 'bar';
}
\end{lstlisting}
Dacă semnătura funcției se pune \^in documentația funcției, atunci analog cu ea
avem \^in codul PHP efectiv ceea ce numim \textsl{antetul funcției} (en. \textsl{function header}),
\^in exemplul anterior acesta fiind
\begin{verbatim}
foo()
\end{verbatim}


Acum că am implementat funcția, o putem apela. Un exemplu complet:
\begin{lstlisting}
<?php
function foo() {
  echo 'bar';
}
foo();
$i=10;
while($i--) {
  foo();
}
\end{lstlisting}
Pe liniile 5 și 8 spunem că am apelat funcția \texttt{foo}, care poartă numele
de \textsl{callee} sau apelat.

După cum observi, poți folosi constructele învățate în capitolul anterior în
jurul funcțiilor. La fel de bine poți folosi constructele respective
și în implementația funcțiilor. De exemplu, această funcție afișează numerele
de la 0 la 10:
\begin{lstlisting}
<?php
function count_to_10() {
  for($i=0;$i<=10;$i++) {
	echo $i,' ';
  }
}
count_to_10();
\end{lstlisting}

Funcțiile pot accepta și parametri. Putem spune că am parametrizat
funcția sau că am parametrizat algoritmul implementat de acea funcție. Parametrii
adaugă un plus de flexibilitate.


Ce se întâmplă dacă vrem să numărăm
de la 0 la un număr variabil? Algoritmul nu se schimbă, numai că
trebuie să începem de la 0 dar să ne oprim la acel număr specificat
în parametru. Exemplu:
\begin{lstlisting}
<?php
function count_to_n($n) {
  for($i=0; $i<=$n; $i++) {
	echo $i,' ';
  }
  echo '<br />';
}
count_to_n(42);
\end{lstlisting}
Iar documentația funcției ar arăta așa:
\begin{verbatim}
void count_to_n(int $n)
\end{verbatim}

Acel \texttt{int \$n} ne spune că funcția acceptă un parametru care va fi accesibil
din interiorul funcției sub identificatorul \$n, și că tipul de date al acestuia
este integer. În interiorul funcției putem face orice dorim cu acel parametru.

Sau am putea lăsa la o parte identificatorul parametrului în documentație:
\begin{verbatim}
void count_to_n(int)
\end{verbatim}
Asta este posibil deoarece la documentarea funcției nu contează numele parametrului.
Numele parametrului este util doar în implementația funcției, însă noi acum
doar documentăm semnătura funcției, iar în documentație nu trebuie să știm
decât ce tip de date are al X-ulea parametru (aici primul).

În practică însă, este mai bine să spunem și numele parametrului în documentație,
deoarece putem folosi acel identificator al parametrului în descrierea funcționalității
funcției.

\good{Documentează-ți mereu semnăturile funcțiilor tale, cu tot
cu tipurile de date ale parametrilor. Asta te va ajuta să-ți
amintești mai repede cum funcționează propriul tău cod chiar
și după ani de zile în care nu ai lucrat cu acele funcții proprii.}

Pentru a documenta o funcție, scrie-i semnătura deasupra implementăriii,
folosind comentarii. Tot în acele comentarii poți documenta și
ce face fiecare parametru. Exemplu de cod documentat bine:

\begin{lstlisting}
<?php
/**
 * display a space-separated list of numbers, up to $n
 *
 * void count_to_n(int $n)
 */
function count_to_n($n) {
  for($i=0; $i<=$n; $i++) {
	echo $i,' ';
  }
  echo '<br />';
}
\end{lstlisting}

Încearcă să apelezi funcția așa, și observă
ce se întâmplă:
\begin{lstlisting}
count_to_n('foo');
\end{lstlisting}

Cu ajutorul documentației, ți-ai putea da seama ușor care e greșeala,
chiar dacă acel cod este scris de altcineva și îl vezi pentru prima dată.
%TODO CHAP spune ce capitol (phpDocumentor)
Într-un capitol următor vei vedea că există și scule care generează semi-automat
documentație în format HTML, care îți fac navigarea prin cod mai ușoară, 
și care-ți permit să înțelegi cu ușurință cum funcționează aplicații
complexe, chiar dacă acestea îți sunt străine.

\begin{Exercise}[title={Funcție care afișează reprezentarea binară}]
În capitolul trecut a trebuit să scrii de fiecare
dată o buclă atunci când ai vrut să afișezi reprezentarea
binară a unui număr întreg. Cu funcții, nu trebuie
să implementezi acel algoritm decât o singură dată,
să îl ``îmbraci'' într-o funcție, și să apelezi acea
funcție de fiecare dată când ai nevoie de ea. Asta te scapă de
multă muncă inutilă și cod care nu numai că este repetitiv,
dar care mai este și greu de citit.

Scrie o funcție care afișează reprezentarea binară a unui integer.
\end{Exercise}

Afișările făcute în funcții sunt puternice și ne scapă deja de mult
efort. Însă înainte de a ne grăbi să punem o grămadă de \texttt{echo}
în funcțiile noastre, hai să ne întrebăm înainte:\\
\textit{Ce se întâmplă dacă nu vrem să afișăm rezultatul unei funcții, ci să-l
refolosim într-un alt mod?}

Ce se întâmplă dacă nu vrem de exemplu să afișăm reprezentarea binară
a unui număr, ci să o salvăm într-un fișier, o bază de date, sau să
o trimitem prin e-mail?

\textit{Retval comes to the rescue}. \textsl{Retval}, sau corect \textsl{return value},
este valoarea returnată de o funcție. Toate funcțiile pot returna o valoare.

În mod implicit, funcțiile care returnează void, deci care în fapt nu returnează
nimic, returnează de fapt valoarea NULL. Exemplu:
\begin{lstlisting}
<?php
function do_nothing() {
//the do-nothing function is a function
//which has a simple functionality: it does nothing
}
$val = do_nothing();
var_dump($val);
var_dump(do_nothing());
\end{lstlisting}

Pe linia 6, atribuim valoarea returnată de apelul la \texttt{do\_nothing()}
variabilei \texttt{\$val}, și pe linia următoare afișăm această valoare.

Pe linia 8 îi pasăm ca parametru lui \texttt{var\_dump()} direct retval-ul apelului
la \texttt{do\_nothing()}.

\attention{Valoarea returnată de o funcție este tot o valoare (după cum îi spune
însăși numele de return \textit{value}), deci poate fi folosită ca atare
peste tot unde parserul PHP acceptă o valoare.}

Deoarece o valoare este și o expresie, putem pune un apel la o funcție peste tot
unde PHP acceptă o expresie: în condițiile buclelor, între [] pentru a accesa un
anumit index al unui array, ș.a.m.d. Exemplu:

\begin{lstlisting}
if(do_nothing()) {
  echo 'do nothing returns something';
}
\end{lstlisting}
Fluxul de execuție va ajunge la \texttt{if}. O dată ajuns aici, PHP știe că
trebuie să citească o expresie și să o evalueze boolean, deci întâlnește apelul
la o funcție. Deoarece e un apel, funcția se numește și \textsl{apelat},
iar fluxul de execuție trebuie să intre în
acea funcție, să treacă prin implementația funcției,\footnote{Altfel spus, să
apeleze funcția.} și într-un final
să se ajungă la un retval, care în cazul nostru este implicit \texttt{NULL}.

Apoi acest retval este pasat înapoi
apelantului (en. \textsl{caller}),\footnote{Apelantul este entitatea care apelează funcția. În cazul nostru,
este scriptul .php însuși, dar ar putea fi și o altă funcție, deoarece
o funcție poate apela o altă funcție.}
în cazul nostru contextului
semantic de valoare booleană creat de constructul \texttt{if}. O dată ajuns
în acest context, \texttt{NULL}-ul returnat de funcție este evaluat ca \texttt{FALSE}.

Fiind într-o funcție, pentru a returna o anumită valoare în loc
de NULL-ul implicit, trebuie să folosim
constructul \texttt{return}. Sintaxa este simplă și intuitivă:
\begin{verbatim}
return <expr>;
\end{verbatim}

În capitolul trecut am auzit despre \textit{scope}-ul global al variabilelor.
Cu ajutorul funcțiilor, putem vedea în practică ce înseamnă acest \textit{scope}
și ce altfel de \textit{scope}-uri mai există.

Vom discuta pe marginea următorului listing:
\begin{lstlisting}
<?php
function increment($a) {
  $a = 'bar';
  echo "in interior \$a este $a\n";
}
$a = 42;
echo "$a\n";
increment($a);
echo "$a\n";
\end{lstlisting}

Totul ne este cunoscut până la linia 8. La apelarea funcției \texttt{increment()},
parametrul \$a al funcției primește inițial valoarea 42, așa cum ne așteptăm.
Însă fluxul de execuție ajunge pe linia 3, moment în care \$a primește valoarea
constantă 'bar', așa cum ne demonstrează și outputul generat pe linia 4.
Totuși fluxul de execuție revine pe linia 9, moment în care \$a are iar valoarea 42. De ce?

Răspunsul e simplu: parametrul (variabila) \$a al funcției și variabila \$a din scope-ul
global nu au nimic în comun. Sunt două variabile complet diferite.

Variabila \$a din scope-ul global există doar în scope-ul global, iar variabila \$a
folosită ca parametru în interiorul funcției există doar în interiorul funcției.

Voi ilustra asta cu un cod mai sugestiv, redenumind variabila \$a din \textsl{scope}-ul
global:
\begin{lstlisting}
<?php
function increment($a) {
  $a = 'bar';
  echo "in interior \$a este $a\n";
}
$foo = 42;
echo "$foo\n";
increment($foo);
echo "$foo\n";
\end{lstlisting}

Variabila \texttt{\$foo} se află în contextul global, în tabelul cu variabile globale. Atunci când apelăm
funcția \texttt{increment} pe linia 8, ceea ce pasăm funcției nu este variabila \texttt{\$foo}, ci doar
valoarea ei. Această metodă de a pasa parametri se numește \textsl{pass by value}.
Acesta este motivul pentru care cele două scripturi funcționează absolut identic, deși
variabilele sunt numite diferit. Aici nu este vorba despre numele variabilelor, ci de
valorile lor (fluxul de date) și pe unde trece execuția (fluxul de execuție).

În momentul în care fluxul de execuție intră în funcție,
PHP crează un nou tabel de variabile, care,
pentru că e nou, e gol. Ți-ai dat seama de asta, nu?
Orice variabilă declarată sau folosită în această funcție se pierde o dată cu ieșirea
fluxului de execuție din funcție.

PHP vede însă că funcția acceptă și un parametru numit \texttt{\$a}, și îl crează și pe acesta, însă
tot în tabelul de variabile al \textit{scope}-ului \textsl{local} funcției \texttt{increment()}.
Din acest motiv, logica și operațiile din interiorul funcției sunt complet decuplate
de "lumea exterioară".

Datorită faptului că PHP crează și distruge automat scope-uri, dacă în interiorul
unei funcții am face lucruri precum în listingul \ref{lst:varvarfromassoc},
atunci nu am polua scope-ul global. Acele variabile variabile create ar exista
doar în interiorul funcției, și ar fi distruse o dată ce fluxul de execuție
părăsește funcția.


O funcție poate accepta oricâți parametri. În astfel de cazuri, ei trebuie separați
prin virgulă unul de altul. Exemplu:
\begin{lstlisting}
<?php
function add($a, $b) {
  return $a + $b;
}
$foo = add(42,43);
echo $foo;
\end{lstlisting}

\attention{Nu uita că introducerea de noi variabile ar trebui făcută doar
atunci când avem de gând să refolosim acele variabile.}

\good{Atunci când creezi o funcție care returnează valori numerice
ca "statusuri de eroare", crează constante simbolice în afara funcției
pentru aceste statusuri și returnează acele constante simbolice în
loc de numerele efective. Astfel poți schimba valorile efective returnate,
însă cei care îți apelează funcția o vor folosi așa cum au folosit-o mereu,
deoarece numele constantelor simbolice nu se schimbă.}

În exemplul de mai sus, așa cum e el, introducerea variabilei \texttt{\$foo}
este o practică proastă, era suficient să îi pasăm retval-ul
funcției direct lui \texttt{echo}:
\begin{lstlisting}
echo add(42,43);
\end{lstlisting}

Țin să subliniez încă o dată: retval-ul unei funcții este o valoare
ca oricare alta. Este creată transparent pentru noi de PHP, la fel
cum într-un exemplu precum:
\begin{lstlisting}
<?php
'a' . 'b';
\end{lstlisting}
din 'a' și 'b' rezultă o valoare nouă 'ab' transparentă pentru noi, în urma concatenării.

\begin{Exercise}[title={Execuția liniară nu conține mereu toate verificările dintr-o condiție},difficulty=2]
Explică de ce funcția \texttt{pass\_is\_correct} este apelată
în cazul următor
\begin{lstlisting}
<?php
function pass_is_correct($password) {
  echo 'vom confrunta parola cu valoarea corecta ';
  return 'foo' === $password;
}
$input = 'bar';
if(!empty($input) && pass_is_correct($input)) {
  echo 'autentificat';
}
\end{lstlisting}
dar nu este apelată în cazul următor:
\begin{lstlisting}
<?php
function pass_is_correct($password) {
  echo 'vom confrunta parola cu valoarea corecta ';
  return 'foo' === $password;
}
$input = '';
if(!empty($input) && pass_is_correct($input)) {
  echo 'autentificat';
}
\end{lstlisting}
\end{Exercise}

\begin{Exercise}[title={Fluxul de execuție și apeluri nested la funcții},difficulty=1]
Fie codul:
\begin{lstlisting}
<?php
function foo($a) {
  return $a+1;
}
function bar($b) {
  return $b*42;
}
echo foo(bar(foo(foo(38))+2));
\end{lstlisting}
Explică pe rând pe unde trece fluxul de execuție și perechile de operații
de adunare și de înmulțire care sunt executate.
\end{Exercise}

Există o modalitate de a rupe izolarea inerentă creării de scopuri noi
în interiorul funcțiilor: \texttt{global}. Cu acest cuvânt cheie,
poți lega (en. \textsl{to bind}) un identificator din scope-ul local
de scope-ul global. Exemplu:
\begin{lstlisting}
<?php
function increment_foo() {
  global $foo;
  $foo++;
}
$foo = 41;
increment_foo();
echo $foo;
\end{lstlisting}

În cazul nostru concret, o astfel de funcție care accesează și/sau modifică
variabile din scope-ul global este inutilă. Să zicem că funcția
\texttt{increment\_foo()} ar implementa un algoritm complicat, sau nu. Nu
prea contează. Ideea este că o astfel de funcție este strâns legată
de variabila globală \$foo, ceea ce o face nereutilizabilă. Însă
tocmai acesta e scopul unei funcții: un algoritm închis,
ca o cutie neagră, care poate
fi parametrizat și care eventual returnează o valoare ce poate
fi considerată outputul acelui algoritm.

\bad{Din acest motiv, folosirea lui \texttt{global} este o practică proastă.}

Există unele variabile predefinite care sunt în mod automat
globale, fără a trebui să le definim noi ca atare. Din acest
motiv aceste variabile se numesc \textsl{superglobale}.
Printre acestea se numără și \texttt{\$\_GET} și
\texttt{\$\_POST}, pe care le-am folosit pentru
preluarea inputului.

Deși sunt superglobale, deci ne sunt puse la dispoziție
automat de PHP în orice \textit{scope}, fie el global,
fie local unei funcții, acestea nu ar trebui accesate direct
de funcții, ci primite ca parametru, ca orice alte valori.

De exemplu, avem nevoie de o funcție care să ne returneze
toate numerele mai mici sau egale cu 42 primite ca input.
Am fi tentați să procedăm astfel:
\begin{lstlisting}
<?php
function get_all_under_42() {
  $r = array();
  foreach($_GET as $k => $v) {
	if($v <= 42 ) {
	  $r[$k] = $v;
	}
  }
  return $r;
}
var_dump(get_all_under_42());
\end{lstlisting}
Dar ce se întâmplă dacă primim datele prin POST, nu prin GET?
Scriem o nouă funcție pentru POST? Inacceptabil, asta duce
la duplicarea codului în mod inutil. Și mai rău, dacă
vrem să procesăm un array oarecare în acest mod?

Mult mai bine este să creăm o funcție atât de generică încât
să poată fi folosită cu orice array, fie el global,
superglobal, sau local:
\begin{lstlisting}
<?php
function get_all_under_42($data) {
  $r = array();
  foreach($data as $k => $v) {
	if($v <= 42 ) {
	  $r[$k] = $v;
	}
  }
  return $r;
}
var_dump(get_all_under_42($_GET));
\end{lstlisting}
Mult mai elegant, dar mai ales, mult mai
reutilizabil.

Așa cum cuvântul cheie \texttt{global} rupe izolarea creată
automat de \textit{scope}-uri, tot la fel putem rupe ștergerea
automată a unor variabile o dată cu ieșirea din \textit{scope}-ul local
al funcției cu un alt cuvânt cheie: \texttt{static}.

Variabilele statice sunt inițializate prima oară când fluxul
de execuție le întâlnește, și apoi nu mai dispar.

O astfel de variabilă statică poate fi folosită de exemplu
pentru a salva numărul de apeluri la funcția în care se află. Exemplu:
\begin{lstlisting}
<?php
function foo() {
  static $calls=0;
  $calls++;
  return "foo has been called $calls time(s)";
}
echo foo(),PHP_EOL;
echo foo();
\end{lstlisting}

Variabila statică este tot o variabilă locală funcției. Exemplu:
\begin{lstlisting}
<?php
function foo() {
  static $calls=0;
  $calls++;
  return "foo was called $calls time(s)".PHP_EOL;
}
function bar() {
  static $calls=0;
  $calls++;
  return "bar was called $calls time(s)".PHP_EOL;
}
echo foo();
echo bar();
echo foo();
echo bar();
\end{lstlisting}

\begin{Exercise}[title={static vs. global}]
\begin{enumerate}
	\item De ce nu are sens declararea unei variabile statice în scope-ul global?
	\item Dincolo de faptul că PHP nu ne lasă din punct de vedere sintactic, de ce nu are sens
declararea unei variabile statice și globale în același timp, în interiorul unei
funcții?
\end{enumerate}
\end{Exercise}

\subsection{Când să introducem funcții noi}
În acest moment știm ce constructe ne pune PHP la dispoziție și ce
posibilități avem. Acum vom face un pas înapoi și ne vom gândi:
când este necesar să introducem funcții noi, și când nu?

Pentru a înțelege asta, trebuie să înțelegem ce înseamnă
\textit{a programa}.\footnote{Mă refer strict la actul de creație,
nu la documentare, testare, sau alți pași care vor fi introduși
în capitole viitoare}

Atunci când vrem să programăm, o facem pentru că suntem puși în
fața unei probleme. Șeful ți-a spus că trebuie să faci o aplicație
care să facă X, Y, Z, și tu trebuie să o faci. Este problema ta
cum rezolvi această problemă, însă totul pleacă de la ea.

O dată pus în fața unei probleme, este treaba programatorului
să o rezolve. Orice programator va rezolva problema la un
moment dat, însă un programator bun nu numai că va rezolva
problema, dar o va rezolva și în așa fel încât să poată
reutiliza funcționalitățile implementate și în proiectele
viitoare.

De exemplu, foarte multe aplicații web au funcționalitatea
de \textit{login}/\textit{logout}. Un programator naiv
va mâzgăli la grămadă ceva, și va rezolva problema, poate
implementația sa va fi foarte rapidă, iar șeful va fi
fericit că a rezolvat-o atât de repede.

Dar acea implementație nu va fi reutilizabilă în aplicațiile
viitoare, programatorul va pierde la fiecare aplicație
același timp constant, pentru că de obicei fiecare aplicație
are unele cerințe specifice, unice, în ciuda faptului că
funcționalitatea este în mare aceeași.

Pe termen lung, programatorul naiv va pierde cumulativ mai mult timp
decât un programator care investește inițial mai mult timp și
energie, \textit{dar} care recuperează din acest timp
cu fiecare nou proiect.

Programatorul bun va rupe problema mare în subprobleme mai mici.
Aceste subprobleme pot fi constituite la rândul lor din alte subprobleme.

Vom formaliza acest scenariu, pentru o ilustrare mai clară. Avem o problemă fictivă P.
Ea constă în rezolvarea problemelor $P_1$, $P_2$ și $P_3$. Aceste subprobleme
sunt mai puțin complexe decât problema P. $P_1$ la rândul ei poate fi decompusă în alte
două subprobleme, $P_{1_1}$ și $P_{1_2}$.

Trecând la analiza subproblemei $P_2$, programatorul realizează că datele pe care
aceasta operează sunt foarte similare cu datele pe care le-ar returna $P_{1_2}$, deci
practic, făcând abstracție de câteva detalii de implementație, $P_2 = P_{1_2}$.

Folosind deci algoritmii din $P_{1_2}$, programatorul rezolvă o altă subproblemă a lui $P$,
și anume $P_2$.

\attention{Această împărțire (en. \textsl{breaking down}) a problemei se numește \textsl{modularizare}.}

Sună simplu, dar în realitate nu este deloc așa. Programatorul trebuie să analizeze foarte
bine problemele, și să le descompună în subprobleme reutilizabile. Nici măcar la
nivel academic nu există strategii clare de modularizare a codului care să funcționeze mereu.

Ne vom uita la o problemă simplă, care este complexă destul pentru a conține subprobleme reutilizabile,
și pe care o putem rezolva în PHP.

Se dau trei numere, $a$, $b$, $c$, pe care trebuie să le sortăm crescător. Altfel spus, la final
afirmația $a \leq b \leq c$ trebuie să fie adevărată. Numerele pot avea orice valori inițiale.
Cum procedăm?

Dacă nu ai nici o idee, atunci hai să abordăm la modul naiv problema. Din problemă, știm
cu certitudine că
există în total șase posibile ordonări: abc\footnote{prescurtare pentru  $a \leq b \leq c$},
bca, cab, bac, cba, acb. Fiecare ordonare este de fapt o permutație, și deoarece conține trei
elemente se mai numește și triplet de numere.

Un alt lucru cert este că nu putem compara decât două numere în același timp, o expresie
de genul  $a \leq b \leq c$ nefiind posibilă în PHP, ar trebui să unim conjunctiv
 $a \leq b $ și $b \leq c$.

Dacă rescriem cei șase tripleți matematic, în perechi conjunctive, observăm că toate
comparațiile de genul $a \leq b$ apar de două ori. Deci de ce să verificăm de două
ori aceeași condiție, când putem verifica o singură dată? Este un principiu fundamental
în programare: încearcă să reutilizezi cât mai mult din algoritmii implementați.

Astfel, luând de exemplu perechea $a \leq b$, avem două categorii de tripleți:
\begin{itemize}
\item cei ce îndeplinesc această condiție: abc, cab, acb
\item cei ce nu îndeplinesc condiția: bca, bac, cba
\end{itemize}

Practic am simplificat astfel problema, pe ramura TRUE
a comparației tratăm trei cazuri, pe ramura FALSE celelalte
trei cazuri. Dar asta nu e tot. Suntem ambițioși, și vrem să
reflectăm și mai mult asupra problemei.

Care este esența faptului că am stabilit relația dintre cele două
numere $a$ și $b$, și ce legătură are asta cu $c$?

În esență, relația lui $c$ față de perechea $a,b$ poate fi de trei tipuri:
\begin{itemize}
\item ori se află înaintea perechii, deci avem de-a face cu tripletul $cab$ pe ramura TRUE,
sau cu tripletul $cba$ pe ramura FALSE
\item ori se află exact între $a$ și $b$, deci avem de-a face cu tripletul $acb$ pe ramura TRUE sau
cu tripletul $bca$ pe ramura FALSE
\item ori se află după această pereche, deci $c$ este mai mare atât decât $a$, cât și
decât $b$, deci avem de-a face cu tripletul $abc$ pe ramura TRUE sau cu tripletul
$bac$ pe ramura FALSE
\end{itemize}

Asigură-te că toate gândurile expuse de mine până aici ți s-au așezat bine în creier.

Detașându-ne puțin de problemă, realizăm că atât cazul TRUE, cât și cazul FALSE al comparației
$a \leq b$ reutilizează aceeași subproblemă, doar că $a,b$ sunt ordonate diferit, ori ca $ab$, ori ca
$ba$. Perechea $a,b$ este deja ordonată, deci nu ne rămâne decât să inserăm c-ul la poziția corectă.
Perechea $b,a$ nu trebuie decât inversată, astfel încât $b$ să primească valoarea lui $a$, iar $a$ să
primească valoarea lui $b$, deci $a$ și $b$ să fie ordonate unul relativ la altul.


Cum ar arăta asta algoritmic? Hai să o luăm treptat:
\begin{lstlisting}[language=pseudocode]
daca a <= b
  //ceva
altfel
  a,b = b,a
\end{lstlisting}
Exact! După execuția liniei 4, după ce am inversat cele două valori, problema de pe ramura
"altfel" devine problema de pe ramura "daca". Nu avem decât să inventăm o funcție
care acceptă o pereche de numere ordonate $a,b$ și încă un număr $c$, funcție care inserează
$c$ la poziția corectă, înainte, după, sau între $a,b$. Această funcție va putea
fi apelată atât pe ramura TRUE, cât și pe ramura FALSE a fluxului de execuție.

Un singur lucru specific PHP nu îl știm: cum să inversăm două valori. Pentru
asta putem folosi o variabilă intermediară, de exemplu \$t (care stă în mod intuitiv
pentru \textit{temporar}):
\begin{lstlisting}
<?php
$t = $a;
$a = $b;
$b = $t;
\end{lstlisting}

O altă metodă este să folosim un construct PHP: \texttt{list}().
Cu el putem despacheta un array în componentele sale, deoarece îl
putem folosi și de partea stângă a atribuirii:
\begin{lstlisting}
<?php
list($b,$a) = array($a,$b);
\end{lstlisting}
Exact, datorită asociativității de dreapta a atribuirii, mai întâi
creăm un array, apoi îl despachetăm cu list(). Însă îl despachetăm invers!
Astfel, în urmă atribuirii, valoarea lui \$a aterizează în \$b și vice-versa.

Deci codul nostru va arăta așa:
\begin{lstlisting}
<?php
$a = (int)$_GET['a'];
$b = (int)$_GET['b'];
$c = (int)$_GET['c'];
if($a <= $b) {
  list($a,$b,$c) = insert_at_right_pos($a,$b,$c);
}
else {
  list($a,$b) = array($b,$a);
  list($a,$b,$c) = insert_at_right_pos($a,$b,$c);
}
echo "$a <= $b <= $c";
\end{lstlisting}

\begin{Exercise}[title={Insert at the right position},difficulty=3]
\ExePart
Un singur lucru mai lipsește în listingul anterior: implemetarea funcției
\texttt{insert\_at\_right\_pos()}. Implementeaz-o.

\ExePart
Completează următorul cod cu o implementație corectă a funcției
\texttt{sort\_triplet\_desc}:
\begin{lstlisting}
<?php
$a = (int)$_GET['a'];
$b = (int)$_GET['b'];
$c = (int)$_GET['c'];

list($a,$b,$c) = sort_triplet_desc($a,$b,$c);

echo "$a >= $b >= $c";
\end{lstlisting}
\end{Exercise}

Într-adevăr am depus mult mai mult efort în analiza problemei noastre, dar
nu numai că am refolosit cod în mod destul de inteligent în
cadrul aceleiași probleme prin implementația
de funcții, dar aceste funcții vor putea fi refolosite fără prea multe
eforturi în toate proiectele viitoare.

Pentru a împărți o problemă în subprobleme, nu trebuie decât să analizezi
cu grijă problema, inputul, și ce se vrea ca output, și să identifici
funcționalități comune.

Cum trebuie să împarți o problemă nu poate fi învățat din cărți, ci doar
prin practică, având pe cineva lângă tine care să-ți atragă atenția
atunci când ai greșit, și care să-ți dea sfaturi de îmbunătățire
a modularizării codului tău. Pentru acest lucru, comunitatea
{\phpro}\footnote{\url{https://github.com/yet-another-project/phpro-book}}
îți stă la dispoziție, unde persoane cu experiență te vor tutela.

\good{O regulă de bază pe care oricine o poate urma, este să te desprinzi de
output. Una este procesarea cu un algoritm a datelor fundamentale
de la baza aplicației, alta este generarea de output.

Toate funcțiile, poate cu excepția a câtorva, ar trebui să opereze
pe date și atât. Gândește-te că depui efort în rezolvarea unei probleme sau subprobleme,
și vrei ca implementația să fie cât mai reutilizabilă. Ce se întâmplă dacă
nu vrei să afișezi un rezultat în browser, ci să trimiți rezultatul prin
e-mail, sau să generezi documente în alte formate precum PDF în loc
de HTML? În astfel de cazuri va trebui să modifici funcțiile. Sau
altfel spus: în astfel de cazuri spunem că nu ți-ai făcut funcțiile reutilizabile.

Nu uita că, atunci când creezi funcții, acestea trebuie să fie
utile și pentru cazuri pentru care nu au fost gândite de fapt.
Pentru asta, funcțiile tale trebuie să fie în primul rând izolate
de orice ține de mediul sau de circumstanțele în care acestea sunt apelate.
}

\subsubsection{\texttt{Static} is almost bad, \texttt{global} is evil}
În concordanță cu paragraful anterior, \texttt{static} poate fi periculos
dacă interferează cu fluxul de execuție, iar \texttt{global} este
periculos deoarece rupe izolarea pe care ar trebui s-o aibă implementația
fiecărei funcții.

Ca regulă generală, nu uita că o funcție trebuie să returneze aceeași valoare
pentru aceleași valori primite ca parametri, orice s-ar întâmpla între două
apeluri la acea funcție. Exemplu:
\begin{lstlisting}
<?php
function foo($nr) {
  return ++$nr;
}
$a = 41;
echo foo($a);
$b = ++$a;
echo foo($b);
\end{lstlisting}
Această funcție este bine izolată de lumea exterioară, deoarece se manifestă
consistent pentru toate inputurile, indiferent de cum arată fluxul de execuție
și de date în apelant.

\attention{Fluxul de execuție, și implicit și de date,
 dintr-o funcție bine scrisă poate fi anticipat mereu.}

\bad{O practică greșită este să modifici valorile
variabilelor globale sau superglobale în
interiorul funcțiilor.
Astfel de modificări, și în general orice fel de
bizuire pe variabilele globale, trebuie
evitate \textit{cu orice preț}.

Operând pe o variabilă globală sau superglobală,
nu poți ști ce alte părți ale aplicației vor
fi influențate.

Chiar dacă știi în acest moment că nu există riscuri,
nu uita că \textit{vei uita} cum ți-ai construit aplicația
și ce interdependențe de funcționalitate ai creat.
Dar chiar dacă ai uitat, vei fi pus în situația
de a personaliza anumite părți din aplicație.
Este foarte probabil să nu mai fii conștient de
aceste interdependențe în momentul în care vei
personaliza acele lucruri.}

\subsection{Funcții variabile}
Putem salva identificatori de funcții în variabile, ca stringuri, și apela 
acele funcții prin intermediul variabilelor. Exemplu:
\begin{lstlisting}
<?php
function foo($a) {
  return ++$a;
}
$do_it = 'foo';
$test = 41;

echo $do_it($test);
\end{lstlisting}
Nu este nimic deosebit sau dificil în ce se întâmplă.

\attention{Funcțiile variabile îți pot face codul
greu de înțeles și de mentenat. Evită folosirea
lor acolo unde nu rezolvă mai elegant o problemă
sau nu aduc nimic în plus.}

Funcțiile variabile sunt strâns legate de ceea ce numim \textsl{callbacks}.
Un \textit{callback} este o funcție pe care i-o pasăm ca parametru
unei alte funcții. Acea funcție va folosi callback-ul pasat după nevoi.

O astfel de funcție este \texttt{array\_walk}. Ea apelează callback-ul
pentru fiecare pereche key => value a array-ului pe care i-l pasăm ca parametru.

Semnătura funcției este
\begin{verbatim}
bool array_walk(array &$a, callback $cb [, mixed $userdata])
\end{verbatim}
Un exemplu:
\begin{lstlisting}
<?php
$foo = array(
  'foo' => 'bar',
  42 => 'the answer',
  'the question' => NULL
);
function display_array($value,$key) {
  echo "$key => $value<br />",PHP_EOL;
}
array_walk($foo,'display_array');
\end{lstlisting}
Exact, se numește \textit{walk} deoarece se "plimbă" prin array.
Corect spunem că \texttt{array\_walk()} iterează array-ul
cu un \textit{callback}.

\begin{Exercise}[title={Callbacks}]
Implementează o funcție cu următoarea semnătură:
\begin{verbatim}
array call_and_filter(array $array, callback $cb)
\end{verbatim}
unde callback-ul trebuie să aibă semnătura
\begin{verbatim}
bool my_cb(int $key)
\end{verbatim}
care apelează callback-ul pentru toate elementele array-ului și dacă
callback-ul returnează TRUE, atunci adaugă valoarea aflată la \$key
într-un array \$r.

Callback-ul însuși \texttt{my\_cb()} trebuie să returneze TRUE pentru
toate numerele pozitive mai mici sau egale cu 42.

După ce a terminat de iterat array-ul primit ca
parametru, \texttt{call\_and\_filter()} trebuie să returneze array-ul
rezultat \$r.
\end{Exercise}


\subsection{Closures}
Closures, sau funcții anonime, pot fi, la fel ca și funcțiile variabile,
folosite ca callbacks, însă pot avea multe alte întrebuințări.

Se numesc funcții anonime deoarece nu au un nume, doar o implementație.
Deoarece vrem să și folosim o astfel de funcție, trebuie să o salvăm
undeva, și ce altceva s-ar potrivi mai bine decât o variabilă?

De notat este că a salva înseamnă în termeni PHP a atribui, deci
trebuie să fie respectată sintaxa atribuirii:
\begin{verbatim}
$var = <expr>;
\end{verbatim}
Pentru a atribui o funcție anonimă unei variabile, pur și simplu
atribuim implementația funcției variabilei:
\begin{lstlisting}
<?php
$foo = function() {
  return 42;
};

echo $foo();
\end{lstlisting}
Apelul efectiv este la fel ca în cazul funcțiilor variabile,
cu excepția că în cazul lor variabila avea ca valoare un string, însă
acum are ca valoare:
\begin{lstlisting}
var_dump($foo);
\end{lstlisting}
Exact! Un obiect de tip "Closure". Vom reveni asupra
programării orientată pe obiecte
%TODO CHAP say which chapter OOP
într-un capitol viitor.

Numele de \textit{closure} ne spune că ele pot de fapt mult mai mult.
Un \textit{closure} poate "acapara" și variabile din scope-ul în care se află.

De exemplu, acest closure folosește variabila \$a din \textit{scope}-ul global,
deoarece \textit{closure}-ul însuși este declarat în acest \textit{scope}:
\begin{lstlisting}
<?php
$a = 4;
$multiply_by_a = function($b) use ($a) {
  return $a*$b;
};

echo $multiply_by_a(3);
\end{lstlisting}
Clauza \texttt{use} poate accepta,
la fel ca și funcția, o listă de parametri multipli
separați prin virgulă. Această listă conține lista variabilelor
a căror valoare trebuie preluată din \textit{scope}-ul părinte.

Cu adevărat utile devin \textit{closures} când sunt 
create în interiorul altor funcții care crează și
returnează aceste closures, în funcție de parametrii primiți.

Exemplu:
\begin{lstlisting}
<?php
function multiply_by($multiplier) {
  return function($a) use ($multiplier) {
	return $a * $multiplier;
  };
}

$double = multiply_by(2);
$triple = multiply_by(3);

echo $triple($double(1));
\end{lstlisting}
La fiecare apel, \texttt{multiply\_by()} ne va returna
un nou \textit{closure} de tipul necesar.
%TODO CHAP when at strategy pattern, point to this

\begin{Exercise}[title={Afișarea unui array bidimensional}]
La sfârșitul capitolului trecut probabil ai creat un script
care, pornind de la un array asociativ, genera un tabel XHTML.

Scrie o funcție
\begin{verbatim}
string array_table(array $data)
\end{verbatim}
care generează codul XHTML cu reprezentarea acelor date într-un tabel
și care returnează acest cod apelantului.
\end{Exercise}

\subsection{Default values}
Parametrii funcțiilor pot avea valori standard (en. \textsl{default}).
Aceste valori trebuie să fie valori constante precum TRUE, FALSE, NULL,
stringuri sau numere, iar parametrii respectivi iau acele valori doar
dacă apelantul nu specifică o valoare.

Pentru a atribui o valoare default unui parametru, folosim sintaxa deja
cunoscută:
\begin{verbatim}
$param = <value>
\end{verbatim}

De exemplu, o funcție care îl salută pe utilizator în funcție de limbă
poate arăta așa:

\begin{lstlisting}
<?php
function greet($username,$language='en') {
  $greetings = array(
	'en' => 'Hello ',
	'de' => 'Hallo ',
	'ro' => 'Salut ',
	'fr' => 'Salut ',
  );
  return $greetings[$language].$username;
}

echo greet('Flavius','de');
echo greet('Xulescu');
\end{lstlisting}
Deoarece parametrii cu valori default pot fi specificați de
apelant sau nu, acești parametri se mai numesc și opționali.

Parametrii cu valori \textit{default} nu pot sta decât
la sfârșit, iar după ei nu mai pot
apărea parametri obligatorii. O astfel de funcție nu este posibilă:
\begin{verbatim}
void foo($a=42,$bar)
\end{verbatim}
\$bar ar trebui să fie primul parametru, și după el să urmeze parametrii opționali.

\section{Debugging}
Deseori te vei lovi de probleme și va trebui să le izolezi cauza
pentru a le putea repara. Chiar dacă ceea ce vrei nu este să
rezolvi tu însuți problema, ci să apelezi la ajutorul altcuiva,
tot va trebui să o izolezi.

De ce? Motivul e simplu: nimeni nu te poate ajuta fără
a avea o idee concretă despre ce nu funcționează așa cum te
aștepți să funcționeze. De aceea

\good{Nu spune niciodată \textit{Nu merge}. Faptul că
nu merge e evident, din moment ce ai o problemă. În programare
trebuie să spui exact ce nu merge, și să depui efort pentru
a izola exact cauza.}

În primul rând, asigură-te că ai instalat și configurat PHP
pentru dezvoltare, așa cum ești instrucționat în capitolul 1.
Acesta nu este un pas opțional: este foarte probabil ca PHP
să îți spună unde este greșeala, dar tu să nu o vezi pentru
că nu ai configurat PHP corespunzător.

În al doilea rând, apache scrie mesajele de eroare întâlnite
în fișierul \texttt{error\_log} din subdirectorul \texttt{logs}.
Asigură-te că citești și înțelegi ce scrie acolo.

Pentru \engl{depanarea}{debugging} efectivă, folosește \texttt{var\_dump()}
pentru a inspecta valorile variabilelor în puncte
cheie din execuție - poate că unele variabile nu au
valorile pe care te aștepți să le aibă!? Asigură-te
înainte de toate.

Adițional, poți vedea pe unde trece fluxul de execuție
folosind constantele magice \texttt{\_\_FILE\_\_},
\texttt{\_\_LINE\_\_} sau \texttt{\_\_FUNCTION\_\_}:
\begin{lstlisting}
echo 'fluxul de executie trece prin ', __FUNCTION__, '(', __LINE__, ')', PHP_EOL;
\end{lstlisting}

După ce ai izolat problema, scrie un cod minimal de maxim
20-50 LOCs, care să o reproducă. Acest cod se numește
\engl{POC}{Proof of Concept}. Dacă nu reușești să rezolvi
problema, apelează la ajutorul unui tutore {\phpro},
folosind acest POC.

Crearea unui POC nu este un efort inutil. Nu de puține ori
izolarea problemei și reproducerea sa cu ajutorul
unui POC te va duce direct către rezolvarea sa,
și astfel nu vei mai avea nevoie de susținerea cuiva.

Folosirea \texttt{var\_dump()} și a constantelor magice
nu este cel mai profesionalist mod de a depana o aplicație -
în capitolul următor vom vedea și cum se face corect.
Tehnica prezentată aici este doar o metodă improvizată,
suficientă pentru a-ți putea analiza și rezolva
problemele de unul singur.

\section{Folosirea manualului}
Până acum am făcut cunoștință cu posibilitățile limbajului PHP.
Însă pentru a fi util, el trebuie și să pună la dispoziție
funcționalități deja scrise de alți programatori. Aceste
funcționalități sunt de obicei împachetate în funcții.
De exemplu, am folosit deja funcții ca \texttt{var\_dump()},
fără a ne întreba prea multe despre ea.

După cum știi, toate funcțiile au o implementație. Însă
noi nu am implementat nicăieri funcția \texttt{var\_dump()}. Unde
este ea implementată? Răspunsul: într-o extensie PHP.

PHP în sinea lui nu știe să "facă" mult mai multe lucruri decât
am văzut deja. Pentru a-l face cu adevărat util, creatorii
limbajului îl distribuie împreună cu extensii, numite și module.

Pentru a vedea lista modulelor încarcate în PHP, lansează
în CLI \texttt{php} cu parametrul \texttt{\-m}:
\begin{alltt}
php -m\Return
\end{alltt}
Unele module sunt atât de aproape de "inima" interpreterului
PHP, încât nici nu pot fi dezactivate.\footnote{De exemplu
extensia \textit{standard}} Din acest motiv, acestea
par a face parte din PHP. În realitate, limbajul PHP
este doar scheletul, restul funcționalităților
fiind puse la dispoziție de aceste extensii.

De notat este că PHP include nu numai extensii scrise
de inventatorii limbajului PHP, ci mai ales legături
(en. \textsl{bindings})
către bibliotecile altor programe. De exemplu,
GD este o bibliotecă folosită de programatorii C
pentru a desena programatic imagini. PHP doar
pune la dispoziție o interfață prin care aplicațiile
tale scrise în PHP pot apela funcțiile specifice \texttt{libgd}.\footnote{\textit{lib}
este prescurtarea de la \textit{library}.}
Asta permite programatorilor familiari deja cu GD
să scrie aplicații în PHP fără a depune eforturi
prea mari, deoarece conceptele, și chiar și numele funcțiilor,
sunt foarte similare cu cele puse la dispoziție de \texttt{libgd}
direct.

În același timp, programatorii PHP cu cunoștințe C
pot rescrie foarte ușor părți din aplicațiile lor
care inițial erau scrise în PHP, în C, deoarece
ei cunosc deja numele funcțiilor, parametrii,
dar mai ales conceptele din spate specifice \engl{bibliotecii}{library}
GD.

\good{Când înveți să lucrezi cu funcțiile
puse la dispoziție de un modul care pune la dispoziție
o funcționalitate pentru o anumită clasă de probleme,
învață și înțelege în primul rând conceptele din spate.

Astfel vei putea trece de la PHP la altă tehnologie
și totuși îți vei putea folosi cunoștințele,
indiferent de limbajul de programare folosit.}

\subsection{Site-ul oficial php.net}
Intră pe site-ul oficial al limbajului PHP: \url{http://php.net/}.
Urmează link-ul din dreapta sus \textit{my php.net}, și setează-ți
limba ca în figura \ref{fig:php.net lang}.

\begin{figure}[ht!]
  \centering
    \includegraphics{cap03/language.png}
  \caption{Limba php.net}
  \label{fig:php.net lang}
\end{figure}
Setează-ți și următoarele preferințe:
\begin{itemize}
\item \textbf{URL search fallback} -- Function list search
\item \textbf{Mirror site redirection} -- alege un mirror apropiat de locația ta geografică
\end{itemize}
Restul setărilor rămân la atitudinea ta.

Cu Firefox, mai poți adăuga php.net și ca motor de căutare, ca în
figura \ref{fig:php.net search}.

\begin{figure}[ht!]
  \centering
    \includegraphics[width=150bp]{cap03/search.png}
  \caption{Căutare în manualul PHP cu Firefox}
  \label{fig:php.net search}
\end{figure}

Introdu \textit{var\_dum}p în câmpul de căutare, și vei fi condus
către pagina din manual a funcției. Acolo poți vedea
în ordine
\begin{itemize}
\item versiunile PHP în care există funcția
\item o descriere scurtă a funcției
\item semnătura funcției și o descriere pe larg
\item eventuale avertizări
\item lista parametrilor și semnificația lor
\item valoarea returnată
\item exemple de utilizare
\item funcții înrudite
\item comentarii ale altor utilizatori
\end{itemize}
Sunt o grămadă de informații. Practic, manualul
PHP conține toate informațiile de care ai nevoie.
Din acest motiv cartea de față nu încearcă să 
duplice explicațiile pe care le poți găsi în manual,
ci doar să te călăuzească. În plus, comentariile
celorlalți sunt extrem de utile. Foarte rar te vei
afla într-o situație unică în care nu s-a mai aflat
nimeni altcineva și comentariile acelea nu îți vor fi de 
folos. E recomandat să le citești și pe ele.

\good{Cartea nu va explica toate funcțiile folosite
în listinguri. Când întâlnești o funcție nouă,
trebuie să te documentezi din manual.
}
\attention{Ceea ce ți se va explica în carte sunt conceptele
generale și termenii, astfel încât să te poți
descurca singur.}

\subsection{Studiu de caz: funcții variadice}
După cum observi în manual, funcția \texttt{var\_dump()}
are de fapt semnătura
\begin{verbatim}
void var_dump (mixed $expression [, mixed $expression [, $... ]])
\end{verbatim}
\ldots înseamnă că funcția acceptă un număr variabil
de parametri, însă trebuie să fie cel puțin unul.
Astfel de funcții se numesc funcții variadice (en. \textsl{variadic}).

\begin{Exercise}[title={Crează o funcție variadică}]
Caută în manual funcția \texttt{func\_num\_args()} și
toate funcțiile înrudite cu ea pentru a crea
o funcție variadică care returnează produsul parametrilor
pasați.

% \ExePart
% 
% Ce observi? Cum poți îmbunătăți prima funcție, cu respect
% față de a doua?
% TODO cum? nici eu nu mai știu
\end{Exercise}


\subsection{Categoriile de extensii disponibile}
Pe pagina oficială fiind, dacă navighezi către
\texttt{Documentation} $\rightarrow$ \texttt{View online}
$\rightarrow$ \texttt{English},
vei ajunge la indexul
manualului, la pagina sa de start.

Capitolele mari prezentate sunt lucruri precum
\textit{Getting Started} care conține și un tutorial,
\textit{Language Reference}, pe care l-ai
citit ca parte dintr-un exercițiu din capitolul trecut,
\textit{Security} care conține sfaturi de securitate,
și asupra cărora vom reveni și noi
în acest capitol, \textit{Features} îți prezintă
unele capacități ale lui PHP folosite
în mod tipic de aplicații, \textit{PHP at the Core: A Hacker's Guide to the Zend Engine}
îți prezintă inima interpreterului PHP, și alte câteva capitole.

Deocamdată vrem să ne facem o imagine de ansamblu a funcțiilor
puse la dispoziție, din capitolul \textit{Function Reference}.

\textit{Affecting PHP's Behaviour} sunt extensii care afectează
modul fundamental de funcționare al lui PHP. De astfel de funcții
nu vei avea nevoie decât când ajungi la nivelul avansat. Unele
dintre cele mai des folosite extensii din această categorie sunt
așa numitele \textit{opcode cachers},
%TODO CHAP which chapter opcode cacher?
asupra cărora vom reveni într-un capitol viitor.

Extensiile pentru \textit{Audio Formats Manipulation} pun
la dispoziție funcții pentru formate audio de fișiere și metadate
salvate în astfel de fișiere.

\textit{Authentication Services} sunt pentru servicii de autentificare,
utile în situații destul de complexe în care trebuie să integrezi
autentificarea utilizatorilor în alte servicii deja existente, sau să
faci autentificarea folosind servicii centralizate cu care și alte aplicații pot
comunica.

\textit{Date and Time Related Extensions} conțin funcții pentru
lucrul cu date și timp, diferența dintre două date, convertirea
de input care reprezintă date sau timp în formate numerice ușor
de înțeles de către calculatoare\footnote{timestamps} sau fuse orare.

\textit{Compression and Archive Extensions} se ocupă de formate
de fișiere precum \texttt{zip} sau \texttt{phar},\footnote{php archive}
un format de arhivare propriu PHP care-ți permite să incluzi aplicații
întregi dintr-un singur foc, chiar dacă acestea conțin câteva mii
de fișiere cu cod sursă.

\textit{Credit Card Processing} sunt pentru procesarea cărților de credit.

\textit{Cryptography Extensions} sunt utile atunci când vrei să
criptezi informații importante, precum numerele de conturi pe care le
procesezi cu funcțiile de procesare ale cărților de credit.

\textit{Database Extensions} pun la dispoziție extensii pentru
comunicarea cu baze de date. MySQL este unul dintre cele mai folosite
sisteme de management al bazelor de date în aplicațiile
PHP, însă există o grămadă de alte sisteme pentru organizarea
structurată a informațiilor.

\textit{File System Related Extensions} se ocupă cu lucrul cu
fișiere și directoare, citirea sau scrierea din/în fișiere,
listarea fișierelor dintr-un director, informații despre fișiere
precum drepturile de acces sau posesorii acestora.

\textit{Human Language and Character Encoding Support} sunt
printre altele pentru internaționalizarea aplicațiilor.
Dacă vrei să faci o aplicație cu interfața în mai multe
limbi, atunci trebuie să apelezi la funcționalitățile
puse la dispoziție de aceste extensii.

\textit{Image Processing and Generation} sunt pentru
prelucrarea și generarea programatică a imaginilor.

\textit{Mail Related Extensions} sunt pentru
lucrul cu diferite protocoluri sau formate de e-mail.

\textit{Mathematical Extensions} pun la dispoziție
funcții matematice.

HTML este un limbaj bazat pe text.
\textit{Non-Text MIME Output} se ocupă cu
generarea de documente sau resurse în alte formate pe
lângă text precum animații flash sau documente PDF.

Funcțiile din extensiile de \textit{Process Control Extensions}
îți permit să lansezi în execuție alte programe cu interfață
CLI și să
comunici cu acestea fie citind și scriind din/în outputul/inputul
acelor procese, fie prin alte mecanisme precum IPC
(en. \textsl{inter-process communication}).

\textit{Other Basic Extensions} sunt extensii care pun
la dispoziție diferite funcționalități de bază.
Cele mai des întâlnite și folosite sunt cele din
extensia \textit{URLs} și din extensia \textit{Miscellaneous Functions}.

\textit{Other Services} conține o mulțime de extensii. Una dintre
cele mai comune este \textit{sockets}. Cu ea poți deschide
conexiuni programatic, așa cum ai făcut cu telnet, și transfera
date (în orice protocol, nu numai HTTP). Altă extensie folosită des
este \textit{cURL}, cu care poți deschide conexiuni HTTP, fără
a fi nevoit să creezi manual cererile HTTP, așa cum ai face-o cu
\textit{sockets}.

\textit{Search Engine Extensions} sunt extensii care te lasă
să comunici cu alți daemoni care au menirea de a indexa
fișiere și de a te lăsa să cauți după cuvinte cheie de
exemplu. Majoritatea aplicațiilor comune scrise în PHP
nu folosesc aceste servicii deoarece pentru aplicații mici
necesită prea multe resurse. Ele salvează datele în baze de
date, de obicei MySQL, și caută manual. Aceste extensii
pentru \textit{search engine} sunt totuși foarte
utile când vrei să faci ceva extensibil, fără a pune
presiune pe o bază de date. Ele reprezintă de fapt moduri "corecte"
de a implementa funcționalitatea de căutare pe un site.

\textit{Server Specific Extensions} pun la dispoziție
funcții specifice SAPI-ului folosit. Dacă ai instalat
și configurat mediul de programare ca în capitolul 1,
atunci folosești SAPI-ul Apache.

\textit{Session Extensions} pun la dispoziție funcționalitatea
numită \textsl{sesiuni}. Sesiunile permit aplicațiilor web
să "țină minte" utilizatorii și date asociate cu aceștia.
Mulțumită sesiunilor este posibilă autentificarea utilizatorilor.

Categoria \textit{Text Processing} conține extensii pentru
lucrul cu text, cu stringuri. Cele mai folosite extensii
din această categorie sunt \textit{Strings} pentru operații
cu stringuri precum căutare, stabilirea lungimii, ș.a.m.d.
și \textit{PCRE} (en. \textsl{perl-compatible regular expressions}).
PCRE îți permite să verifici dacă un string potrivește o
regulă\footnote{Așa cum ai inventat o regulă pentru
sintaxa limbajului HTML în capitolul 2} și eventual
să și extragi anumite secvențe din acel string.\\
PCRE este puternic, dar consumă și multe resurse,
deci este recomandat să folosești funcțiile simple
din extensia \textit{Strings} atunci când e posibil.

\textit{Variable and Type Related Extensions} pun
la dispoziție funcții pentru lucrul cu tipurile
de date fundamentale din PHP (în afară de stringuri,
care sunt tratate de extensiile prezentate anterior), printre
care array-uri, funcții și variabile. Atunci când ai căutat
informații despre funcția \texttt{func\_num\_args()}
și funcțiile înrudite cu ea, te-ai mișcat prin extensia
\textit{Function Handling}.

Extensiile din categoria \textit{Web Services} sunt folosite
pentru a crea și folosi servicii web. Atunci când aplicația
ta pune la dispoziție un serviciu web, aceasta poate
fi contactată de alte aplicații și informațiile pot
fi procesate programatic mult mai ușor. Același lucru îl
poți face și tu cu alte aplicații care își oferă
funcționalitățile și ca servicii web. De exemplu,
rețelele sociale precum Facebook\footnote{\url{http://facebook.com/}}
sau Twitter\footnote{\url{http://twitter.com/}} pun la dispoziție
astfel de servicii. Asta le permite altor programatori să
creeze programe care postează tweet-uri pe twitter sau
jocuri pe care le poți juca împreună cu prietenii tăi
pe facebook, aplicații care nu au legătură directă
cu firmele originale precum twitter sau facebook în
cazul nostru.

\textit{Windows Only Extensions} pun la dispoziție funcționalități
specifice Microsoft Windows. Acestea nu vor funcționa decât dacă
daemonul cu PHP integrat în el rulează pe windows.
Este recomandat să nu folosești astfel de funcții
decât în cazul în care știi sigur că aplicația ta
va rula într-un mediu controlat, pe windows, deoarece
majoritatea serverelor rulează pe o formă sau alta
de *NIX\footnote{GNU/Linux, *BSD, SunOS, etc}, nu Windows.

\textit{XML Manipulation} pune la dispoziție funcționalitate
pentru lucrul cu fișiere în formatul XML. XML este un format
care-ți permite să structurezi informații arborescente. Din punct
de vedere sintactic este
similar cu HTML, iar combinația dintre HTML și XML a dat naștere
limbajului XHTML. În contrast cu (X)HTML însă, XML nu are
"taguri" predefinite. Programatorii își inventează
propriile formate de date și le dau o semnificație.

Acestea au fost categoriile de extensii disponibile în PHP.
Unele dintre ele vin la pachet cu PHP, altele se află
în ceea ce numim PECL (en. \textsl{PHP Extension Community Library})
și trebuie instalate separat.

Nu uita că deși fac parte din aceeași categorie, două extensii nu
pot comunica una cu alta. De exemplu, dacă ai stabilit o conexiune
cu o bază de date MySQL, atunci nu poți pasa această conexiune
unei funcții care lucrează cu baze de date PostgreSQL. Cele două
extensii sunt complet diferite și independente. Categorisirea
extensiilor este doar modul de organizare a informațiilor în
manualul PHP, pentru o navigare mai ușoară.


\subsection{Extensii de bază}
În categoria \textit{Variable and Type Related Extensions}
este o extensie cu funcții pentru lucrul cu array-uri.
Dacă urmezi link-ul \textit{Array Functions} vei vedea
indexul tuturor funcțiilor pentru array-uri alături de
o descriere scurtă a fiecăreia.

\begin{Exercise}[title={Înțelege manualul}]
Alege cinci funcții de lucru cu array-uri și
explică în cuvinte ce face fiecare, apoi crează
unul sau mai multe coduri sursă care să le demonstreze
utilitatea.
\end{Exercise}
\begin{Exercise}[difficulty=3,title={Explorează manualul}]
În acest moment ai o privire destul de robustă a
limbajului, dar nu știi funcțiile care-ți sunt
puse la dispoziție. Totuși, mulțumită explicațiilor
de până acum, ești capabil să înțelegi manualul.

Rezervă-ți 40-80 de ore (1-2 săptămâni de lucru)
pentru a explora următoarele extensii:
\begin{itemize}
\item \textit{Array},
\textit{Function Handling}, \textit{Variable Handling} din categoria \textit{Variable and Type Related Extensions}
\item \textit{Strings} din categoria \textit{Text Processing}
\item \textit{Miscellaneous Functions} din categoria \textit{Other Basic Extensions}
\end{itemize}
Scrie scripturi de la simple la complexe care se folosesc
de aceste funcții. Documentează-ți scripturile cu comentarii.
La fiecare script scrie și ce-ți trece prin minte, ce observații
ai făcut, ce legături sau analogii ai făcut.

Nu uita să separi \textit{business logic} de \textit{view logic} și să transmiți date ce
rezultă în urma procesării formularelor (\textit{business logic}) către \textit{view logic}
folosind \textit{variabile intermediare}.

Postează fiecare cod sursă pe {\phpro} pentru a te verifica pe parcursul
celor 1-2 săptămâni, încă din momentul în care ai scris ceva nou.\footnote{Nu toate
scripturile deodată} În total ar trebui să ai câteva zeci bune de scripturi, cu
până la 1000 de LOCs sau chiar mai mult.

La fiecare exercițiu explică modul de funcționare \^in ceva asemănător cu
limbaj pseudocod, dar fără a folosi identificatori de variabile
sau a reflecta exact structura codului. Explică \^in schimb motivațiile
de a proceda \^intr-un anumit fel.

Crează un jurnal al tuturor funcțiilor despre care te-ai documentat
singur din manual, cu semnătura funcției și o explicație scurtă
despre ce face\footnote{Explicații scurte se pot găsi pe indexul
funcțiilor din manualul PHP.}.

După aceste 1-2 săptămâni nu îți va mai sta nimic în calea creării
de site-uri destul de complexe {\ldots} cu câteva mici excepții pe care le vom
aborda \^in cele ce urmează.
\end{Exercise}



%TODO ce altfel de explicații aș mai putea adăuga pentru a clarifica ev. nelămuriri?
%TODO pune-i pe cursanți să învețe din manual lucruri ca lucrul cu fs sau printf() & co și observă dificultățile





\section{Structuri de date}
Array-urile sunt atât de versatile încât pot fi folosite
pentru a construi structuri de date mai complicate, fiecare
cu avantajele și dezavantajele sale.

\subsection{Stack și queue}
Un \textsl{stack} este un array în care elementele sunt adăugate la sfârșit,
și preluate tot de la sfârșit. Operația de adăugare a unui element
pe \textit{stack} se numește \textsl{push}, iar cea de scoatere se numește \textsl{pop}.

Un \textit{stack} poate fi reprezentat vizual ca în figura \ref{fig:stack}.

\begin{figure}[ht!]
  \centering
    \includegraphics[scale=.3]{cap03/stack-crop.pdf}
  \caption{Operațiile cu un stack}
  \label{fig:stack}
\end{figure}

Deoarece ultimul element adăugat este primul care este îndepărtat
din \textit{stack}, spunem că un \textit{stack} este o structură de date
de tip \textsl{LIFO} (en. \textsl{last in, first out}).

Operația \textit{push} îți este cunoscută deja prin intermediul
operatorului \texttt{[]} pe care l-ai întâlnit în
listingul \ref{lst:push_operator}. Există și o funcție
absolut echivalentă în funcționalitate cu acesta: \texttt{array\_push()}.

Similar cu LIFO, există și FIFO (en. \textsl{first in, first out}),
numit și \textsl{queue}. Operațiile se numesc \textsl{shift} și \textsl{unshift},
iar grafic ne putem imagina o astfel de structură de date ca în
figura \ref{fig:queue}.

\begin{figure}[ht!]
  \centering
    \includegraphics[scale=.3]{cap03/queue-crop.pdf}
  \caption{Operațiile cu un queue}
  \label{fig:queue}
\end{figure}

Primul element pus în \textit{queue} este primul
element care va fi îndepărtat din \textsl{queue}.

Pentru aceste două operații există două funcții numite
destul de intuitiv \texttt{array\_shift()} și
\texttt{array\_unshift()}.



\begin{Exercise}[title={Experimentează cu stack și queue}]
Scrie un script complet în care experimentezi cu
aceste structuri de date. Nu uita că poți trata
același array alternativ, când ca \textit{stack}, când ca \textit{queue}.
\end{Exercise}

\subsection{Structuri de date recursive}
În exercițiul \ref{ex:sintaxa_html} \textit{Sintaxa HTML} ai
făcut cunoștință cu recursivitatea. În PHP poți procesa
structuri de date recursive folosind funcții recursive.
De exemplu,
un document HTML este o structură de date recursivă
deoarece nodurile din
document\footnote{DOM - \href{http://en.wikipedia.org/wiki/Document_Object_Model}{document object model}}
pot avea în interiorul lor alte noduri. Din acest motiv
spunem că structurile de date recursive sunt și izomorfice.

În capitolul trecut ai văzut cum poți construi array-uri
n-dimensionale, unde n era bine determinat.

Un array recursiv este constituit, la fel ca și un array
n-dimensional, din alte array-uri. Diferența este că
n nu este determinat. Trebuie să parcurgem recursiv
array-ul pentru a procesa fiecare element.

%TODO file cap03/family-tree* no longer needed

Vom lua ca exemplu un array recursiv:
\begin{lstlisting}
<?php
$arbore = array(
  'hello',
  'foo',
  'world' => array(
        'how',
        'are',
        'you',
        'today?' => array(
          'march',
          27,
          2010
        )
  ),
  'out',
  'there!'
);

foreach($arbore as $k => $v) {
  if(is_string($v)) {
	echo "$k => $v";
  }
  elseif(is_array($v)) {
	echo " *** RECURSIVITY";
  }
  echo PHP_EOL;
}
\end{lstlisting}
Practic nu este nimic nou. Iterăm array-ul și afișăm
valorile. Însă pe linia 23 detectăm dacă valoarea însăși
este la rândul ei tot un array (precum \texttt{\$arbore},
pe care tocmai îl iterăm), și afișăm \texttt{" *** RECURSIVITY"}.

Țin să subliniez: valoarea \$v este un array, și chiar
dacă se află în interiorul unui array \$arbore, este tot un
array, deci \$v poate fi iterat cu exact aceeași buclă
\texttt{foreach}
cu care iterăm \$arbore.

Practic, nu trebuie decât să reutilizăm codul de pe liniile
19-27. Și ce modalitate cunoaștem pentru a reutiliza codul?
Exact, funcțiile!

Deci implementăm o funcție
\begin{verbatim}
void itereaza_recursiv(array $arbore)
\end{verbatim}
și o apelăm, astfel:
\begin{lstlisting}
<?php
$arbore = array(
  'hello',
  'foo',
  'world' => array(
        'how',
        'are',
        'you',
        'today?' => array(
          'march',
          27,
          2010
        )
  ),
  'out',
  'there!'
);

function itereaza_recursiv($arbore) {
  foreach($arbore as $k => $v) {
        if(is_string($v) || is_numeric($v)) {
          echo "$k => $v";
          echo PHP_EOL;
        }
        elseif(is_array($v)) {
          echo "going into '$k'\r\n";
          itereaza_recursiv($v);
        }
  }
}

itereaza_recursiv($arbore);
\end{lstlisting}
După cum observi, funcția \texttt{itereaza\_recursiv()} se apelează
pe ea însăși pe linia 27, însă cu o altă valoare -- cu
valoarea elementului curent \$v, care este tot un array.
Pe linia 27 spunem că intrăm în recursivitate. La primul apel,
la elementul \texttt{'world'}, intrăm în adâncimea 1
a arborelui. În cadrul elementului \texttt{'world'}
se află încă un element la cheia \texttt{'today?'}
care are ca valoare un array. Atunci când se ajunge la el,
spunem că intrăm în adâncimea 2 "a recursivității".

După ce am afișat valoarea \texttt{2010}, ieșim din recursivitatea
de adâncime 2, revenind la 1, și ne aflăm iar în array-ul cu
cheia \texttt{'world'}. Însă ajunși aici, ne aflăm iar
la sfârșitul iterației, deoarece bucla \texttt{foreach}
ajunge la sfârșitul array-ului salvat în elementul \texttt{'world'},
deci ieșim din recursivitate (și deci din funcția \texttt{itereaza\_recursiv()}),
revenind \ldots tot în funcția \texttt{itereaza\_recursiv()}!

Însă acum ne aflăm pe linia 28, și nu ne aflăm la sfârșitul recursivității
de "adâncime" 0, deci bucla foreach trece la următorul element: \texttt{'out'}.



\begin{Exercise}[title={Adâncimea recursivității},difficulty=2]
Modifică funcția \texttt{itereaza\_recursiv()} dându-i semnătura:
\begin{verbatim}
string itereaza_recursiv(array $arbore, $depth=0)
\end{verbatim}
și modifică implementația astfel încât fiecare afișare
de forma \texttt{"cheie => valoare"} să aibă în fața sa
un număr de spații egal cu adâncimea din recursivitate la care
se află acel element, structura arborescentă fiind
astfel evidențiată și grafic:
\begin{verbatim}
0 => hello
1 => foo
going into 'world'
  0 => how
  1 => are
  2 => you
  going into 'today?'
    0 => march
    1 => 27
    2 => 2010
2 => out
3 => there!
\end{verbatim}
Funcția nu trebuie să afișeze direct cu \texttt{echo},
ci să returneze outputul ca string, din motive
de modularizare.

Scriptul trebuie să funcționeze ca script CLI,
nu printr-un daemon http, deci pentru a genera
o linie nouă în output folosește constanta
\texttt{PHP\_EOL}, pe care o cunoști deja.
\end{Exercise}

Până acum am lucrat cu propriile structuri de date
recursive. Vei fi confruntat deseori cu necesitatea
de a inventa astfel de structuri de date, însă
și mai des va trebui să procesezi date recursive
asupra cărora nu ai control. Un astfel
de exemplu este un director, căci un director poate avea
fișiere și alte directoare în el. Observi recursivitatea?

Lucrul cu fișiere și directoare se poate face
cu ajutorul extensiilor din categoria
\textit{File System Related Extensions}, mai exact
ne interesează în special extensia \textit{Directory Functions}.
Din extensia \textit{Filesystem Functions} avem nevoie
doar de funcțiile \texttt{is\_dir()} și \texttt{is\_file()}
pentru a verifica dacă un element este director sau
fișier.

Începem prin doar a itera un director, fără
a intra recursiv în alte subdirectoare:

\begin{lstlisting}
<?php
function display_directory($dirpath) {
  $dh = opendir($dirpath);
  while($entry = readdir($dh)) {
	echo $entry;
	if(is_dir($dirpath.DIRECTORY_SEPARATOR.$entry)) {
	  echo DIRECTORY_SEPARATOR;
	}
	echo PHP_EOL;
  }
  closedir($dh);
}

display_directory(__DIR__);
\end{lstlisting}
\texttt{opendir()} ne returnează o resursă. Acesta este
un alt tip de date fundamental în PHP, însă
el nu poate fi creat direct de scripturile noastre,
ci doar prin intermediul funcțiilor native PHP,
implementate în extensii.

Deschizând un director cu \texttt{opendir()} avem
acces la această resursă și îl putem itera.

Cu \texttt{readdir()} citim fiecare intrare din acest
director, salvând rezultatul în \texttt{\$entry}.
Această variabilă este fie un string, fie FALSE,
dacă am iterat totul, caz în care condiția buclei
\texttt{while} va fi FALSE, deci se va ieși din
bucla din fluxul de execuție.

Pe linia 6 verificăm dacă noua intrare este un
director, și dacă da, afișăm și valoarea
constantă \texttt{DIRECTORY\_SEPARATOR}.
Diferite sisteme de operare folosesc diferite
separatoare în căile către fișiere și directoare.
MS Windows folosește \texttt{\textbackslash}, în timp ce GNU/Linux
folosește \texttt{/}. Constanta \texttt{DIRECTORY\_SEPARATOR}
va avea mereu valoarea corespunzătoare platformei
pe care rulează scriptul.

Afișarea acestei
constante este doar un indiciu vizual pentru noi,
să știm dacă avem de-a face cu un fișier, sau cu un
director. În practică, aici ar trebui să
intrăm recursiv în noul subdirector.

Toate\footnote{Aproape toate} directoarele
au două pseudo-directoare în ele: \texttt{'.'}
și \texttt{'..'}. Acestea nu sunt directoare
în adevăratul sens al cuvântului, ci sunt referințe,
primul către directorul însuși, al doilea către
directorul părinte. Cu siguranță ai folosit
deja în HTML căi relative precum
\begin{lstlisting}[language=HTML]
<img src="../img/me.jpg">
\end{lstlisting}
De aici vine acel \texttt{'..'}.

\begin{Exercise}[title={Determinarea recursivă a conținutului unui director},difficulty=2]
În funcția anterioară, în loc de simpla afișare
a valorii \texttt{DIRECTORY\_SEPARATOR}, vrem să intrăm în
directorul respectiv. Extinde și modifică funcția
astfel încât să aibă semnătura
\begin{verbatim}
array get_directory_structure(string $dir_path)
\end{verbatim}
și să returneze fișierele și toate subdirectoarele din
directorul \$dir\_path într-un array recursiv.
\end{Exercise}

\begin{Exercise}[title={Afișarea unei structuri de date recursive},difficulty=1]
\ExePart

Implementează o funcție
\begin{verbatim}
string render_recursive_array_to_ul(array $array)
\end{verbatim}
care acceptă ca parametru un array (eventual recursiv) și returnează
reprezentarea HTML a acestuia într-o listă neordonată (\texttt{<ul>}).

Acestei funcții îi vei putea pasa valoarea returnată
de un apel la \texttt{get\_directory\_structure()} implementată
în exercițiul anterior.

Observi cum implementația de funcții care operează
doar pe date abstracte (aici: array-uri) duc
automat la reutilizarea și o mai bună
modularizare a codului?

\ExePart

Extinde funcția astfel încât să accepte și o funcție anonimă
ca \textit{callback}:
\begin{verbatim}
string render_recursive_array_to_ul(array $array,callback $cb=NULL)
\end{verbatim}
care dacă este prezent, este folosit pentru a genera outputul
ce trebuie pus între \texttt{<li>} și \texttt{</li>}.
Semnătura callback-ului trebuie să fie
\begin{verbatim}
string cb(string $path)
\end{verbatim}
\end{Exercise}

\section{Call Stack}
Atunci când apelăm o funcție, PHP pune contextul actual de execuție
pe un stack (operația \textit{push}), și apoi se apelează funcția.
La ieșirea din funcție (cu un \texttt{return}), PHP face un
\textit{pop} pentru acel stack, și execuția se continuă de unde
fusese întreruptă anterior.

Acest stack se numește \textsl{call stack}, fiecare element
de pe acest stack fiind numit \textsl{call frame}.
\section{Fișiere multiple}
Până acum ne-am structurat scripturile în funcții reutilizabile pe de o parte,
și pe de alta separând \textit{business logic} de \textit{view logic}, însă
totul se afla într-un singur fișier. Nu puteam refolosi nici logica, nici
prezentarea, separate una de alta.

PHP ne pune la dispoziție patru directive pentru includerea unui fișier în
alt fișier .php. Primele două se numesc \texttt{include} și \texttt{require}.
Sintaxa este destul de intuitivă:
\begin{verbatim}
include <string>;
require <string>;
\end{verbatim}

Exemplu:
\begin{lstlisting}[title=index.php]
<?php
if(isset($_GET['nume']) && is_string($_GET['nume'])) {
  $nume = $_GET['nume'];
}

if(isset($nume)) {
  include 'greet_nume.php';
}
include 'greeting_form.php';
\end{lstlisting}
\begin{lstlisting}[title=greet\_nume.php]
Salut <?php echo $nume; ?>.
\end{lstlisting}
\begin{lstlisting}[title=greeting\_form.php,language=html]
<form method="GET" action="index.php">
  <input type="text" name="nume" />
  <input type="submit" value="greet" />
</form>
\end{lstlisting}

Bineînțeles exemplul nostru nu este atât de complex încât 
avantajele să devină evidente. Un avantaj posibil ar fi că putem schimba modul
de funcționare extrem de ușor, fără a modifica nici un alt
fișier în afara lui \texttt{index.php}.

Așa cum este acum, scriptul afișează formularul indiferent
dacă avem numele ca input sau nu. Am putea schimba rapid în afișarea
formularului doar dacă numele nu a fost trimis de utilizator, modificând
\texttt{index.php} astfel:
\begin{lstlisting}[title=index.php,firstnumber=6]
if(isset($nume)) {
  include 'greet_nume.php';
}
else {
  include 'greeting_form.php';
}
\end{lstlisting}
fără a ne atinge de nici un alt fișier.

Alt avantaj e că am putea refolosi \texttt{greet\_nume.php} oricând
vrem să salutăm pe cineva. Nu ar trebui decât să ne asigurăm că există variabila
\texttt{\$nume}, deoarece aceasta este folosită de acel script.

Diferența dintre \texttt{include} și \texttt{require} constă în cum
tratează PHP absența fișierului inclus. Cu \texttt{include}, PHP generează
o avertizare dar continuă execuția. Cu \texttt{require}, execuția se oprește
complet dacă fișierul nu există sau PHP nu îl poate citi. De aceea,
este recomandat să folosim \texttt{require} atunci când știm că aplicația
nu ar avea oricum să-și îndeplinească (măcar parțial) execuția fără
fișierul php pe care vrem să-l injectăm în runtime-ul php.

\attention{Sub MS Windows, \textbackslash trebuie precedat de un alt \textbackslash
în stringurile interpolate atunci când sunt declarate căi pentru filesystem.}

Celelalte două directive pentru includerea codului de fișiere este familia
\texttt{*\_once}. Sintaxa:
\begin{verbatim}
include_once <string>;
require_once <string>;
\end{verbatim}
Așa cum le spune și numele, aceste constructe vor include fișierul doar o singură
dată. Asta este foarte util dacă fișierul inclus conține implementările unor funcții,
deoarece, dacă am implementa o funcție cu același nume de mai multe ori, PHP
ne-ar spune că nu putem redeclara acea funcție. Exemplu:
\begin{lstlisting}
<?php
include_once 'functions.php';
include_once 'functions.php';//nu va mai fi inclus inca o data
echo foo();
\end{lstlisting}
Unde funcția \texttt{foo()} este implementată în fișierul \texttt{functions.php}.
Totuși în acest caz ar fi mai bine să folosim \texttt{require\_once}, astfel încât dacă
fișierul \texttt{functions.php} nu există, execuția să fie întreruptă din start.
Nu are rost să încercăm să executăm un cod care apelează o funcție care nu există,
deoarece fișierul în care ar trebui să fie implementată nu există.

\subsection{Șabloane}
În exemplul anterior, \texttt{greet\_nume.php} se numește \engl{șablon}{template}.
Folosirea lui este însă dependentă de existența unei variabile numită \texttt{\$nume},
ceea ce face \textit{template}-ul nostru să fie cuplat de această variabilă, la fel
cum și cuvântul cheie \texttt{global} cuplează numele unei variabile de o funcție.

Putem decupla foarte elegant orice template de variabilele folosite
în el creând o funcție precum:
\begin{verbatim}
void render(string $template, array $vars=NULL)
\end{verbatim}
unde \texttt{\$template} este calea către un fișier .php folosit
ca template, iar \texttt{\$vars} este un array asociativ. Acest array
va fi iterat ca în listingul \ref{lst:varvarfromassoc}, creând astfel
variabilele cerute de template-ul \texttt{\$template}. Aceste variabile
vor fi locale funcției \texttt{render()},\footnote{Se vor afla doar în scope-ul local
al funcției} deci nu vor polua nici un scope, fiind șterse automat de PHP
atunci când fluxul de execuție iese din funcție. În același timp, variabilele
specifice template-ului nu vor fi cuplate de \textit{scope}-ul global, așa cum \texttt{\$nume}
folosit de \texttt{greet\_nume.php} era cuplat de \texttt{\$nume} din \textit{scope}-ul
global (\texttt{index.php}).

După ce variabilele variabile
au fost create, o simplă instrucțiune de includere a fișierului va genera outputul.

Dacă funcția nu primește un al doilea parametru de la apelant, atunci \texttt{\$vars}
va avea valoarea \texttt{NULL}, și nu ar trebui să mai creăm variabilele variabile,
ci doar să includem \textit{template}-ul.

\begin{Exercise}[title={O funcție render()}]
\ExePart
Scrie o funcție
\begin{verbatim}
void render(string $template, array $vars=NULL)
\end{verbatim}
care crează variabile variabile pe baza array-ului asociativ \$vars
și apoi include \$template.

Exemplu de apelare a acestei funcții:
\begin{lstlisting}
render('greet_nume.php',array('nume' => $nume));
\end{lstlisting}

\ExePart

Rescrie funcția \texttt{render()} folosind funcția internă
\texttt{extract()}.
%TODO WIKI: explică ce e o funcție internă și că trebuie înlocuit cu foreach
\end{Exercise}
În exemplul din exercițiul anterior am apelat funcția cu parametrul
\texttt{array('nume' => \$nume)}. În PHP există funcția \texttt{compact()}
care poate crea un array asociativ cu numele variabilelor ca chei, și
valorile acestora ca valori în array. Este o funcție foarte utilă
atunci când numele variabilelor din \textit{scope}-ul actual (în cazul de
față cel global) sunt numite la fel ca variabilele folosite în
\textit{template}-ul în cauză.


\subsection{Primul site complet}
Hai să vedem cum putem folosi toate lucrurile învățate sau nu până acum. Includ
și lucrurile neînvățate, deoarece mă aștept să te documentezi din manual
atunci când întâlnești o funcție necunoscută.

O vom lua gradual, adăugând treptat funcționalitate, și deci și complexitate.

Vrem să facem un site personal cu câteva pagini. Întregul site va prezenta
pe toate paginile un meniu comun cu lista paginilor existente. 

\begin{figure}[H]
  \centering
    \includegraphics[scale=.5]{cap03/homepage-layout-crop.pdf}
  \caption{Layout site personal}
  \label{fig:layout site personal}
\end{figure}

Toate paginile vor
arăta similar, doar conținutul efectiv al fiecărei pagini fiind diferit. Spunem că site-ul
folosește un \textit{template}. Acesta va arăta ca în figura \ref{fig:layout site personal}.


\begin{Exercise}[title={Crează template}]
Crează un fișier XHTML 1.1 structurat ca
în figura \ref{fig:layout site personal}. Alegerea culorilor și așezarea
în pagină sunt lăsate la atitudinea ta, dar meniul trebuie să fie
definit așa:
\begin{lstlisting}[language=html]
<div id="menu">

</div>
\end{lstlisting}
iar continutul așa:
\begin{lstlisting}[language=html]
<div id="content">

</div>
\end{lstlisting}
\end{Exercise}

Pentru site-ul nostru,
am fi tentați să punem acest \textit{template} în \texttt{index.php}.
Asta nu ar fi o decizie bună, deoarece nu am putea reutiliza \textit{template}-ul
în alte locuri. \texttt{index.php} ar trebui doar să coordoneze
conlucrarea dintre \textit{business logic} și \textit{view logic}.
Deci pune template-ul creat într-un fișier nou numit \texttt{layout.php}.
Acum creăm și index.php, care va afișa template-ul. Ulterior urmează să adăugăm
și procesările (\textit{business logic}) corespunzătoare:
\begin{lstlisting}[title=index.php]
<?php
require_once 'functions.php';
//here be processing

render('layout.php');
\end{lstlisting}
Crează și fișierul \texttt{functions.php} și pune
în el implementația funcției \texttt{render()} creată
în unul din exercițiile anterioare.

Acum hai să facem layout-ul să folosească câteva variabile:
\texttt{\$title}, \texttt{\$menu}, și \texttt{\$content}.
Înlocuiește astfel încât să ajungi la:
\begin{lstlisting}[numbers=none]
<title><?php echo $title;?></title>
\end{lstlisting}
\begin{lstlisting}[numbers=none]
<div id="menu"><?php echo $menu;?></div>
\end{lstlisting}
și
\begin{lstlisting}[numbers=none]
<div id="content"><?php echo $content;?></div>
\end{lstlisting}

Deoarece \textit{template}-ul folosește acum aceste
variabile, trebuie să i le exportăm. Deci adaugă
un array asociativ corespunzător:
\begin{lstlisting}[title=index.php]
<?php
require_once 'functions.php';
$tpl_vars = array(
  'title' => 'My Homepage',
  'menu' => 'no menu yet',
  'content' => 'no content yet'
);

render('layout.php',$tpl_vars);
\end{lstlisting}

Însă am spus că vrem să afișăm diferite pagini, fiecare pagină cu conținutul ei, și
în plus fiecare pagină să aibă un link în meniu.

Cu siguranță ne-am putea apuca să mâzgălim niște cod la grămadă, și cu siguranță
ne va ieși ceva aspectuos. Dar cel mai probabil nu ne va ieși ceva reutilizabil
dacă nu stăm să ne gândim puțin mai profund și mai sistematic de ce avem nevoie.

Încă o dată, rezumăm: o pagină are
\begin{itemize}
\item un titlu, pus în <title></title> în template
\item un conținut
\item un meniu
\end{itemize}
În exemplul de mai sus, conținutul este la noi un string. Însă acest conținut
va diferi de la pagină la pagină, și cel mai probabil va fi foarte lung.

Am putea teoretic să punem conținutul fiecărei pagini într-un string, însă
asta ar face codul foarte greu de citit și mentenat. Mult mai curat ar fi
dacă am considera un nume de fișier ca fiind caracteristica "conținut"
a acelei pagini. Altfel spus, o pagină ar consista din:
\begin{itemize}
\item un titlu, pus în <title></title> în template
\item un fișier cu conținutul efectiv
\item un meniu
\end{itemize}
Deci am putea crea o structură de date abstractă care să conțină o pagină.
Deoarece avem o serie de trei caracteristici pentru o pagină, putem
salva aceste informații despre fiecare pagină într-un array asociativ:
\begin{lstlisting}
$home = array(
  'title' => 'Bine ai venit',
  'content' => 'home.php',
  'menu' => 'no menu yet'
);
$about = array(
  'title' => 'Despre mine',
  'content' => 'despre.php',
  'menu' => 'no menu yet'
);
\end{lstlisting}
Nu m-am grăbit să creez și meniul pentru fiecare pagină, deoarece
am realizat că acest meniu ar putea fi determinat programatic, pe baza
variabilelor precum \texttt{\$home} sau \texttt{\$about}. Ce ar implica
generarea automată a meniului pentru fiecare pagină? Exact! Ar
implica iterarea acestor variabile. Însă noi nu putem itera variabile.
Putem itera array-uri. De aici ne vine ideea genială de a salva toate
paginile într-un array asociativ. 
Hai să vedem cum va arăta \texttt{index.php}

\begin{lstlisting}
<?php
require_once 'functions.php';

$pages = array(
  'home' => array(
	'title' => 'Bine ai venit',
	'content' => 'home.php',
	'menu' => 'no menu yet'
  ),
  'about' => array(
	'title' => 'Despre mine',
	'content' => 'despre.php',
	'menu' => 'no menu yet'
  )
);

$tpl_vars = array(
  'title' => 'My Homepage',
  'menu' => 'no menu yet',
  'content' => 'no content yet'
);

render('layout.php',$tpl_vars);
\end{lstlisting}
Realizăm două lucruri:
\begin{itemize}
\item variabila \texttt{\$tpl\_vars} devine inutilă -- toate informațiile se află acum în \texttt{\$pages},
chiar dacă nu în exact aceeași formă. De exemplu, va trebui să găsim o metodă de a "citi" fișierul .php
cu conținutul, deoarece nu vom mai avea la dispoziție conținutul efectiv ca string
\item variabila \texttt{\$pages} este ca un fel de \textit{variabilă de configurare}.
Atunci când am separat \textit{business logic} de \textit{view logic},\footnote{folosind
funcția proprie \texttt{render()}} am spus că misiunea lui \texttt{index.php} este să
coordoneze conlucrarea dintre diferite componente, deci deși este posibil să
punem configurațiile într-un astfel de script "de coordonare", mult mai curat ar fi
să separăm și configurarea de celelalte două procese izolate, și anume \textit{business logic}
și \textit{view logic}
\end{itemize}
Pentru primul punct avem puțin mai mult de muncă, dar pentru al doilea există o soluție
foarte elegantă. Familia de directive \textit{include} nu numai că include
un fișier, dar și este evaluat ca valoarea returnată de fișierul inclus.\footnote{Astfel
de detalii, dar multe altele, pot fi citite în manualul PHP, capitolul
\textit{Language Reference}} Astfel
am putea avea un fișier de configurare \texttt{pages.php}:
\begin{lstlisting}[title=pages.php]
<?php
return array(
  'home' => array(
	'title' => 'Bine ai venit',
	'content' => 'home.php'
  ),
  'about' => array(
	'title' => 'Despre mine',
	'content' => 'despre.php'
  )
);
\end{lstlisting}
Iar index-ul nostru va deveni mult mai curat:
\begin{lstlisting}
<?php
require_once 'functions.php';
$pages = require_once 'pages.php';

render('layout.php');
\end{lstlisting}

Pentru a afișa diferite pagini, nu trebuie decât să acceptăm un
parametru prin \texttt{\$\_GET} în funcție de care să
decidem care dintre pagini trebuie afișată.

\attention{Fișierul de configurare \texttt{pages.php} constituie
ceea ce putem numi \textsl{configuration logic}. În interiorul lui
putem genera chiar și programatic configurația, folosind condiții,
bucle, și orice altceva ce ține de controlul fluxului de execuție.
Trebuie însă să fim atenți să nu denaturăm natura acelor informații
care urmează a fi returnate. Iar de îndată ce am returnat o configurație,
este bine să nu ne mai atingem de ea. Altfel riscăm să alergăm după
greșeli de programare greu de identificat.}

Vom modifica corespunzător \texttt{index.php}:

\begin{lstlisting}[title=index.php]
<?php
require_once 'functions.php';
$pages = require_once 'pages.php';

if(isset($_GET['show']) && array_key_exists($_GET['show'], $pages)) {
  $page = $_GET['show'];
}
else {
  $page = 'home';
}

render('layout.php',$pages[$page]);
\end{lstlisting}
Însă asta ne va afișa ca conținut numele fișierelor, nu conținutul acelor
fișiere, care nici măcar nu există încă.

Deci crează mai întâi un subdirector \texttt{pages} și în el două fișiere
\texttt{home.php} și \texttt{despre.php} cu un conținut HTML
la alegere. Apoi modifică layout-ul astfel încât să includă fișierul
pe care-l primește în variabila \texttt{\$content}, în loc să îl afișeze
direct:
\begin{lstlisting}[numbers=none,language=html]
<div id="content">
<?php include __DIR__ . '/pages/' . $content; ?>
</div>
\end{lstlisting}

Un ultim lucru mai avem de făcut: să construim meniul dinamic,
pe baza informațiilor din \texttt{\$pages}. Membrul \texttt{'menu'}
al fiecărei pagini din \texttt{\$pages} nu își are rostul, constituie
doar informații redundante ce pot fi deduse din \texttt{\$pages}.

Deci vom crea o funcție care ia ca parametru un array precum \texttt{\$pages}
și generează un meniu HTML. Deoarece o astfel de funcție
are rol ajutător, și în fapt marginal funcționării aplicației
dincolo de formatul HTML, numim o astfel de funcție un \textsl{helper}.
Funcția va avea semnătura:
\begin{verbatim}
string build_menu_from_pages(array $pages)
\end{verbatim}
Implementația o adăugăm în fișierul \texttt{functions.php}
\begin{lstlisting}[numbers=none,title=functions.php]
function build_menu_from_pages($pages) {
  $r = '<ul>';
  foreach($pages as $pagename => $metadata) {
	$r .= '<li><a href="?show='.$pagename.'">'.$metadata['title'].'</a></li>';
  }
  return $r.'</ul>';
}
\end{lstlisting}

Felicitări. Acum nu numai că ai un site, dar ai o structură
flexibilă pe a cărei fundație poți adăuga ușor pagini noi.
Pentru a adăuga o pagină nouă de exemplu, tot ce trebuie
să faci este să o creezi în subdirectorul \texttt{pages}
și să o înregistrezi ca pagină validă în \texttt{pages.php},
alături de metadate despre pagină precum titlul paginii.
În rest, nu trebuie să te atingi de nici un alt cod,
nu trebuie să muți sau să editezi cod, iar meniul va fi
construit automat.

Pentru recapitulare, figura \ref{fig:filestruct-homepage}
prezintă încă o dată structura de fișiere creată
și scopurile lor.

\begin{figure}[H]
  \centering
    \includegraphics[scale=.5]{cap03/structure-homepage-crop.pdf}
  \caption{Structura fișierelor unui site simplu}
  \label{fig:filestruct-homepage}
\end{figure}

\begin{Exercise}[title={Îmbunătățește-ți pagina personală},difficulty=1]
\ExePart
Momentan meniul conține link  si pentru pagina activă,
ceea ce nu prea are sens. Extinde funcția
\texttt{build\_menu\_from\_pages} astfel încât să
nu genereze link pentru pagina activă momentan, ci
doar să o afișeze în lista neordonată ca text.

\ExePart
\texttt{index.php} conține \textit{business logic}-ul site-ului tău.
Extinde acest \textit{business logic} astfel încât pentru
paginile inexistente să arate o pagină \texttt{notfound.php}.
\texttt{home.php} trebuie să rămână în continuare pagina de
start standard a site-ului.

\ExePart
Adaugă încă o pagină \textit{Despre tine}
care afișează informații despre vizitator din array-ul superglobal
\texttt{\$\_SERVER}.

Dacă știi CSS, stilizează site-ul așa încât să fie mai aspectuos.
Nu va trebui să modifici în nici un fel layout-ul sau
paginile individuale. Vei lucra doar cu CSS.
%TODO wiki: posibilă greșeală: folosirea $_SERVER direct în view
\end{Exercise}

Din partea I a exercițiului se observă în practică un alt avantaj
al funcțiilor: nu trebuie să editezi multe fișiere în lungul
și-n latul proiectului, nu te atingi de \textit{business logic}
sau de \textit{view logic} deoarece nu modifici modul fundamental de funcționare
al acestora. Doar îmbunătățești funcția, iar
modificările sunt preluate automat în toate locurile de unde
aceasta este apelată.

\section{Directorul curent de lucru}
Căile relative către fișiere și directoare,
sunt relative la ceea ce numim \textsl{current working
directory}. La \textsl{runtime} (în timpul execuției
scriptului), putem afla CWD-ul cu
funcția \texttt{getcwd()}, și schimba CWD-ul cu \texttt{chdir()}.

În exemplele anterioare, instrucțiuni precum
\begin{lstlisting}
<?php
require_once 'functions.php';
\end{lstlisting}
au funcționat deoarece directorul curent de lucru \texttt{'.'}
este specificat în mod standard în directiva \texttt{php.ini}
\texttt{include\_path}. Modul corect de a include un fișier, fără
a ne baza pe faptul că acesta se află în \texttt{include\_path}, ar fi
\begin{lstlisting}
<?php
require_once './functions.php';
\end{lstlisting}
unde \texttt{'.'} se referă la CWD.

Dacă avem însă un scenariu mai complex, cu următoarele fișiere:
\begin{figure}[ht!]
  \centering
    \includegraphics[scale=.7]{cap03/cwdtree.png}
  \caption{Scenariu includere}
  \label{fig:cwdtree}
\end{figure}

\begin{lstlisting}[title=index.php]
<?php
require_once './functions/foo.php';

echo 'index.php este in directorul ',__DIR__,PHP_EOL;

echo 'apelul la foo() genereaza:';
foo();
echo PHP_EOL;
\end{lstlisting}

\begin{lstlisting}[title=functions/foo.php]
<?php
require_once './foo/foobar.php';
function foo() {
        echo __DIR__;
}
\end{lstlisting}

\begin{lstlisting}[title=functions/foo/foobar.php]
<?php
function foobar() {
}
\end{lstlisting}

atunci toate fișierele sunt incluse prin prisma fișierului
\texttt{index.php}, deci CWD-ul este directorul
în care se află acest fișier. Asta nu este
o problemă pentru linia 2 din \texttt{index.php},
deoarece directorul \texttt{'.'} coincide
cu directorul în care se află \texttt{index.php}.

Însă devine o problemă atunci când din fișierul
inclus \texttt{foo.php} vrem să includem
un alt fișier dintr-un alt subdirector
\texttt{functions/foo/}, deoarece CWD-ul nu se
schimbă, și deci, relativ la directorul
în care se află \texttt{index.php}, nu există
un subdirector \texttt{./foo/foobar.php}.

O metodă foarte elegantă la problema asta este să definim
o constantă în \texttt{index.php}, constantă care
va fi folosită la includerea fișierelor. Astfel am
avea:

\begin{lstlisting}[title=index.php]
<?php
const APP_ROOT = __DIR__;
require_once APP_ROOT . '/functions/foo.php';

echo 'index.php este in directorul ',__DIR__,PHP_EOL;

echo 'apelul la foo() genereaza:';
foo();
echo PHP_EOL;
\end{lstlisting}

\begin{lstlisting}[title=functions/foo.php]
<?php
require_once APP_ROOT . '/functions/foo/foobar.php';
function foo() {
        echo __DIR__;
}
\end{lstlisting}
Cu această tehnică vom avea în lungul și-n latul
aplicației constanta \texttt{APP\_ROOT} care
conține mereu calea către directorul în
care se află în \texttt{index.php}, indiferent
de fișierul prin care trece momentan fluxul
de execuție.

Cu adevărat flexibilă devine această metodă
atunci când avem aplicații multiple care
folosesc un set comun de funcții. Nu va trebui
să copiem fișierele de colo colo, ci vom
dezvolta doar o singură "versiune" a acestor
funcții comune, definind o constantă 
de genul \texttt{APP\_LIB} cu calea către
directorul ce conține fișiere PHP
cu implementările funcțiilor noastre. Din a doua aplicație
care dorește să folosească funcțiile primei
aplicații, nu trebuie decât să definim
\texttt{APP\_LIB} ca calea către
directorul cu funcții din prima aplicație,
cea "originală".

Și mai curat din punct de vedere organizatoric
este să punem toate aceste funcții într-o
locație neutră, astfel încât să nu aparțină
nici unui proiect, și din toate
proiectele să definim calea către acea
locație.

O altă tehnică implică folosirea tocmai
a acestei constante magice  \texttt{\_\_DIR\_\_}.

Cu această tehnică nu mai e nevoie
să definim constante "globale" precum \texttt{APP\_ROOT},
însă nici nu mai putem reutiliza porțiuni
de funcționalitate în lungul și-n latul
diferitelor proiecte independente unul de celălalt.

Un astfel de cod ar arăta astfel:
\begin{lstlisting}[title=index.php]
<?php
require_once './functions/foo.php';
foo();
\end{lstlisting}

\begin{lstlisting}[title=functions/foo.php]
<?php
require_once __DIR__ . '/foo/foobar.php';
function foo() {
}
\end{lstlisting}

\begin{lstlisting}[title=functions/foo/foobar.php]
<?php
function foobar() {
}
\end{lstlisting}

\good{Includerea fișierelor ar trebui să o faci mereu folosind
căi absolute, precum o constantă globală aplicației sau cu
constanta magică \texttt{\_\_DIR\_\_}.

Atunci când folosești căi absolute, PHP nu trebuie să ia
la rând căile din \texttt{include\_path}, ceea ce îl absolvă
pe PHP de multe accese ale hard-disk-ului - aceste accese
fiind destul de costisitoare.}

\section{Formulare II. File uploads}
Cu PHP, poți oferi utilizatorului posibilitatea de a salva fișierele
proprii pe hard disk-ul serverului. Este ceea ce numim \textsl{file upload}.

Formularele care conțin câmpuri pentru upload trebuie să fie trimise
cu metoda HTTP POST, și să fie codate ca \texttt{multipart/form-data}.

Un exemplu:
\begin{lstlisting}[title=index.php]
<?php
require_once __DIR__ . '/functions.php';

echo '<pre>';
var_dump($_FILES);
echo '</pre>';
?>
<form enctype="multipart/form-data" method="POST">
<input type="hidden" name="MAX_FILE_SIZE"
	value="<?php echo return_bytes(ini_get('upload_max_filesize'));?>" />
<input name="myfile" type="file" />
<input type="submit" value="Send" />
</form>
\end{lstlisting}

\begin{lstlisting}[title=functions.php]
<?php
function return_bytes($val) {
  $val = trim($val);
  $last = $val[strlen($val)-1];
  switch($last) {
	case 'g':
	case 'G':
	  $val *= 1024;
	case 'm':
	case 'M':
	  $val *= 1024;
	case 'k':
	case 'K':
	  $val *= 1024;
  }
  return $val;
}
\end{lstlisting}
Codul este destul de sugestiv. La primirea fișierelor (cu succes sau cu erori, nu
contează), informațiile\footnote{metadatele} despre ele vor fi disponibile
în array-ul superglobal \texttt{\$\_FILES}.

Elementul \texttt{'error'} din fiecare set de metadate va conține
codurile de eroare pe care le poți compara
cu constantele specifice\footnote{\url{http://www.php.net/manual/en/features.file-upload.errors.php}}
pentru a determina cauza erorii.

\good{Este recomandat să folosești aceste constante predefinite, precum
\texttt{UPLOAD\_ERR\_OK}, în loc de valorile numerice concrete, pentru
o mai bună portabilitate.}

Elementul \texttt{tmp\_name} este calea absolută către fișierul efectiv.
Atunci când utilizatorul uploadează un fișier, acesta primește un nume
temporar aleatoriu, și este salvat acolo unde specifică
directiva de configurare \texttt{php.ini} \texttt{upload\_tmp\_dir}.

Numele real al fișierului, așa cum a fost uploadat de utilizator,
se află în \texttt{'name'}.

\texttt{'type'} este tipul MIME al documentului.

Alte directive care influențează upload-ul de fișiere sunt
\begin{itemize}
\item \texttt{post\_max\_size} pentru mărimea totală a datelor trimise prin POST, mărime care include
	  cumulativ mărimea tuturor datelor trimise, nu numai a fișierelor
\item \texttt{max\_input\_time} limitează timpul pe care PHP are voie să îl petreacă
  procesând datele trimise. Acest timp depinde în mare măsură de rata de upload
  a clientului și de rata de download a serverului
\item \texttt{file\_uploads} poate activa sau dezactiva uploadul de fișiere dintr-un foc
\item \texttt{max\_file\_uploads} limitează numărul de fișiere ce pot fi uploadate de
  client într-o singură cerere HTTP
\end{itemize}

Din moment ce fișierul uploadat se află într-un director ce nu aparține
aplicației noastre, cu un nume aleatoriu, va trebui să
îl mutăm în interiorul aplicației noastre. Pentru
a verifica dacă un fișier este un fișier uploadat folosim
\texttt{is\_uploaded\_file()}, iar pentru a muta
acel fișier, folosim \texttt{move\_uploaded\_file()}.


\good{Deschide manualul PHP și documentează-te despre aceste funcții.
Manualul conține exemple de utilizare și o mulțime de comentarii
din partea altor utilizatori din care cu siguranță poți
învăța câte ceva.}

\begin{Exercise}[title={Remote file storage},difficulty=2]
\ExePart

Crează o aplicație care permite utilizatorilor să
uploadeze fișiere pe serverul tău.

Utilizatorii vor trebui să introducă și un nume secret
care va fi folosit de aplicație pentru crearea unui subdirector
corespunzător, director în care va fi pus fișierul uploadat.

Fișierele uploadate se vor afla deci în directorul
\texttt{uploads/<nume secret>/}. Astfel, utilizatori
care se cunosc între ei vor putea uploada colaborativ
fișiere, lucrând cu un \texttt{<nume secret>} comun.

Folosește funcții ca \texttt{is\_dir()} și
\texttt{mkdir()}. Explorează manualul dacă te
lovești de necesitatea folosirii altor funcții.

Nu uita să verifici toate erorile posibile și
imposibile, și că aplicația trebuie să
se comporte normal și să genereze cod \textit{XHTML 1.1} valid, chiar și atunci
când aplicația ta generează erori.

Nu uita nici de separarea \textit{business logic}-ului
de \textit{view logic}. Construiește-ți aplicația
cât mai modularizat posibil.

\ExePart
Ce găuri de securitate identifici?
% dacă numele există deja, userul \^iși poate da seama de asta
\end{Exercise}

\section{Lucrul cu fișiere}
Până acum am lucrat cu fișiere ca entități opace, fără
a citi din sau a scrie în ele.

PHP pune la dispoziție funcții pentru lucrul
cu fișiere. Așa cum în paginile trecute am deschis un
director pentru a-l itera, și apoi l-am închis, eliberându-l,
tot la fel putem lucra și cu informațiile salvate în fișiere.

Pentru a opera pe un fișier, trebuie să îl deschidem cu
\texttt{fopen()}. Ne alegem cu un \textsl{file handler}
care va fi pasat ca parametru funcțiilor următoare
de manipulare a fișierelor.

Deschiderea fișierelor se face în moduri precum "citire",
"scriere" sau "adăugare". O listă completă ale acestor
moduri se găsește pe pagina \texttt{fopen()} din manualul
PHP.

Atunci când deschidem fișierul, dispunem de un cursor\footnote{Numit și
\textit{file pointer} în manualul PHP.}
pe care îl putem plimba în lungul și-n latul fișierului.
În funcție de modul în care am deschis fișierul, acest
cursor se va afla imediat după deschiderea
fișierului cu \texttt{fopen()} fie la începutul, fie la sfârșitul
fișierului. În modul \textit{read}, cursorul se va
afla la început. În modul \textit{append}, la sfârșit.

Citirea din fișier o facem cu \textsl{fread()}, funcție căreia trebuie
să-i spunem și ce lungime maximă în bytes vrem să aibă segmentul
de informație citit.
La apelarea acestei funcții, cursorul va fi înaintat cu numărul
de bytes citiți.

Deoarece nu știm ce mărime are fișierul, va trebui să citim
în mod repetat din fișier, într-o buclă, până când ne aflăm
la \engl{sfârșitul fișierului}{end of file}, prescurtat EOF.
Pentru a testa dacă am ajuns la EOF, folosim funcția \texttt{feof()}.

După ce am terminat de operat pe fișier, trebuie să-l închidem cu
\texttt{fclose()}.

\begin{Exercise}[title={Citește din fișier}]
Scrie un program care 
citește un număr aleatoriu de bytes între 1 și 32 dintr-un fișier deja existent
și afișează stringurile citite la fiecare iterație în câte
un bloc HTML \texttt{<pre></pre>}.

Dacă fișierul nu este \textit{readable}, programul trebuie
să arate un mesaj de eroare corespunzător.

Pentru generarea de numere aleatoare folosește funcția
\texttt{rand()} din extensia \textit{Math} a categoriei
de extensii \textit{Mathematical Extensions}.

Citește cu atenție paginile din manual ale funcțiilor pentru
lucrul cu fișiere menționate mai sus, secțiunile \textit{User
Contributed Notes} și explorează și alte posibilități
dincolo de ceea ce te interesează pentru rezolvarea acestui
exercițiu urmând link-urile din secțiunile \textit{See Also}
ale acestor funcții.
\end{Exercise}

De multe ori vom fi nevoiți să structurăm informațiile aflate \^in
fișiere. De exemplu hai să ne imaginăm că vrem să facem un guestbook.

Asta \^inseamnă că utilizatorul intră pe pagina noastră și completează
c\^ampuri precum \textit{nume} și conținut. Teoretic am putea citi
aceste informații și le-am putea adăuga la sf\^arșitul unui fișier
care ar avea funcția de ``bază de date''. Acest
fișier ar conține toate impresiile lăsate de toți vizitatorii noștri.

Dar ce facem dacă vrem să edităm o anumită intrare? Ar trebui să
deschidem \^intregul fișier și să navigăm p\^ană la intrarea \^in cauză
pentru a o edita. \^in afară de asta, ne-ar fi greu să identificăm
bucata de text pe care o vrem.

Pentru a structura informațiile dintr-un fișier, e suficient să
introducem o sintaxă nouă. De exemplu, am putea spune că
cele două c\^ampuri de date \textit{nume} și \textit{text} sunt separate
de caracterul \texttt{|}. ``Baza noastră de date'' ar
putea arăta astfel:
\begin{verbatim}
Flavius|Hello world
Florin|Hello back
\end{verbatim}
Ce se \^int\^amplă dacă numele meu este \textsl{Fla|vius}? Caracterul separator
\texttt{|} va trebui escaped și el.

Din fericire există un format de date deja larg răsp\^andit iar PHP ne
pune la dispoziție funcții pentru lucrul cu el. Formatul se numește
\textsl{comma-sepparated values} (abv. CSV).
Separatorul acestui format este virgula, iar funcțiile fac escaping automat. Aceste funcții sunt
\texttt{str\_getcsv()}, \texttt{fgetcsv()}, \texttt{fputcsv()}.

CSV este un format ce se pretează pentru date tabelare. Un alt format este \texttt{INI}. Formatul
unui fișier .ini este
\begin{verbatim}
;this is a comment
[section1]
key1=value1
key2=value2

[section2]
key1=value1
array[]=value2
array[]=value3
\end{verbatim}

După cum putem deduce din exemplu, formatul .ini se pretează pentru perechi de valori,
numite și dicționare. Adițional, aceste perechi pot fi grupate \^in secțiuni.

Pentru lucrul cu acest format avem la dispoziție funcțiile
\texttt{parse\_ini\_string()} și \texttt{parse\_ini\_file()}.

Manualul PHP conține multe exemple și detalii despre aceste funcții
și formate de date.

\subsection{Filesystems}

Un \textsl{filesystem} (abv. FS) este un mod de organizare a fișierelor
și directoarelor pe \textit{hard disk}. Există nenumărate
astfel de \textit{filesystems}, specifice unor anumite
sisteme de operare, sau create pentru a rezolva anumite tipuri
de probleme. De exemplu, utilizatorii Microsoft Windows folosesc
de obicei \textsl{NTFS}, utilizatorii *NIX \textsl{ext2}, \textsl{ext3}
sau \textsl{ReiserFS}, iar pentru accesarea transparentă a fișierelor
de pe un alt calculator conectat prin rețea de nodul curent se
poate folosi \textsl{NFS} (en. \textsl{Network File System}).

Sub GNU/Linux există însă mai multe tipuri de ``fișiere'':
fișierele normale, directoarele, link-uri simbolice (en. \textsl{symlinks}),
\textsl{device}, \textsl{named pipe} și \textsl{unix socket}.

Deoarece nu știm pe ce fel de platformă va rula aplicația (scriptul)
nostru, este imperativ să verificăm dacă ceea ce urmează să deschidem
este \^intr-adevăr un fișier sau un director cu \texttt{is\_file()}
și respectiv \texttt{is\_dir()}.

Unele \textit{filesystems} oferă posibilitatea de a specifica 
un proprietar al unui fișier sau director, sau drepturi de acces.
De aceea este recomandat să folosești funcții precum \texttt{is\_readable()}
sau \texttt{is\_writable()} \^inainte de a deschide fișierele
sau directoarele \^in cauză pentru citire din sau scriere \^in ele.

\^In cazul \^in care creezi programatic fișiere, nu uita că
umask-ul procesului PHP determină drepturile standard de acces
ale fișierului nou creat. Deasemenea nu uita că utilizatorul sub
care rulează parserul PHP va fi proprietarul fișierelor create
programatic.\footnote{De obicei numele utilizatorului din sistem
este ``nobody'', ``httpd'' sau ``http'', dar
nu este recomandat să te bazezi pe astfel de standarde nescrise.}
Pentru a schimba sau verifica aceste setări, PHP pune la dispoziție
funcții precum \texttt{umask()} și \texttt{chmod()}.

Pentru a \^iți testa extensiv aplicațiile pe diferite platforme
precum MS Windows sau GNU/Linux, \^iți recomand să folosești
programe de virtualizare. O listă de resurse despre acestea
și despre GNU/Linux este pusă la dispoziție de comunitatea
{\phpro} prin intermediul articolelor.


%TODO fix colaborativ -> nu există în DEX, cooperativ???
\begin{Exercise}[title={Remote file storage cu editare text on-site},difficulty=1]
Extinde aplicația creată la exercițiul anterior astfel încât
utilizatorii să poată edita fișierele de tip text direct
pe site, cu un textbox.
\end{Exercise}

\section{Cookies, sesiuni, autentificare}
Pentru a \^ințelege cum funcționează autentificarea, trebuie să
reiterăm lucrurile \^invățate \^in primul capitol despre HTTP.

Clientul stabilește o conexiune TCP/IP cu daemonul și \^ii
trimite o cerere \^in formatul HTTP. Această cerere
este formată din \textit{request line} și \textit{request headers}.

Daemonul răspunde cu \textit{response headers} și \textit{response body}.
După ce aceste lucruri au avut loc, conexiunea dintre client și daemon
este \^inchisă. Din acest motiv, spunem că HTTP este un protocol \textsl{stateless}.

Clientul vine și pleacă după cum poftește, se conectează, \^iși ia datele,
și apoi pierdem legătura cu el. Putem \^insă să \^ii trimitem niște informații ``speciale''
pe care un client (un browser) cooperativ ar trebui să le salveze pe hard disk-ul
utilizatorului și să ni le trimită iar atunci c\^and se conectează ulterior
la noi și ne cere ceva. Aceste bucăți de informații se numesc \textsl{cookies}.

Mărimea maximă a unui cookie este de 4 kb \^in aproape toate browserele moderne și
des \^int\^alnite, iar numărul de cookies pe care un domeniu are voie să
le seteze variază de la browser la browser. \^In trecut limita era de
20, dar chiar și asta este mult pentru o aplicație tipică,
modernă, scrisă \^in PHP,
unde de obicei un singur cookie este suficient.

Deci hai să ne jucăm cu cookies:

\begin{lstlisting}[title=Folosirea cookie-urilor]
<?php
setcookie('random',rand(100,999));
var_dump($_COOKIE);
\end{lstlisting}

Linia 2 setează un cookie numit ``random''.
Vom crea o cerere HTTP cu telnet pe portul 80:
\begin{verbatim}
GET /cookie.php HTTP/1.1
Host: localhost

\end{verbatim}

Să zicem că noi, folosind telnet, suntem un browser care cooperează urm\^and
exact ceea ce ne spune daemonul să facem.
Dacă \^in exemplul de mai sus am primit ca răspuns
\begin{verbatim}
Set-Cookie: random=139
\end{verbatim}
atunci, la vizita următoare, \^ii vom pasa acest cookie daemonului,
cu valoarea pe care ne-a transmis-o.

Deci trimitem cererea:
\begin{verbatim}
GET /cookie.php HTTP/1.1
Host: localhost
Cookie: random=139

\end{verbatim} 
Și primim răspunsul
\begin{verbatim}
HTTP/1.1 200 OK
Date: Thu, 21 Oct 2010 13:20:17 GMT
Set-Cookie: random=278

array(1) {
  ["random"]=>
  string(3) "139"
}
\end{verbatim} 

Cookie-ul numit 'random' are acum altă valoare, 278, așa cum este generat de linia 2 din script. \^Insă
array-ul superglobal \texttt{\$\_COOKIE} nu conține acea nouă valoare generată și trimisă
clientului. \texttt{\$\_COOKIE} conține doar ceea ce a fost trimis de client.

\attention{Din aceasta deducem că \texttt{\$\_COOKIE} conține tot input, și
ca orice input, trebuie verificat, filtrat și sanitizat.}

Al treilea parametru al funcției \texttt{setcookie()} este \textsl{timestamp}-ul p\^ană
c\^and va fi valabil acel cookie. Dacă nu e specificat, un browser poate
șterge acel cookie de \^indată ce este \^inchis. 

Timestamp reprezintă numărul de secunde care au trecut de la 1 ianuarie 1970. Se mai numește
și UNIX timestamp. Numărul de secunde se calculează \^in fusul orar GMT.\footnote{Deoarece
are decalaj 0} Pentru a șterge un cookie, pur și simplu setăm data expirării \^in trecut.

Pentru restul parametrilor ar trebui să consulți manualul PHP. Dacă ai \^intrebări
despre folosirea cookie-urilor, comunitatea {\phpro} \^iți stă la dispoziție.

Cookie-urile sunt utile atunci c\^and vrei să salvezi preferințele vizitatorului
pe site. De exemplu indiciile vizuale precum limba preferată \^in care ar
trebui afișat site-ul sau care meniuri sunt vizibile și care nu.

Cookie-urile nu ar trebui folosite pentru salvarea datelor sensibile sau personale
precum username, parolă, sau orice alte date care nu vrei să fie setate aleatoriu
de client. Pentru că nu uita, aceste informații sunt lucruri pe care
clientul le poate scrie după buna sa plăcere, așa cum am făcut-o noi cu telnet.

Pentru a salva informații compozite\footnote{adică array-uri} \^in cookies
poți serializa
și deserializa informațiile folosind diferite formate, fie inventate de tine,
fie puse la dispoziție de PHP:
\begin{itemize}
 \item nativ PHP: \texttt{serialize()} și \texttt{unserialize()}
 \item URL-encoded: \texttt{http\_build\_query()} și \texttt{parse\_str()}
 \item JSON: \texttt{json\_encode()} și \texttt{json\_decode()}
\end{itemize}


\subsection{Sessions}
O formă ``specială'' de cookie este așa numita \textsl{session cookie}.
O session cookie nu conține informații prețioase pentru un eventual atacator,
ci un simplu ID unic. Numele cookie-ului care va conține ID-ul poate fi
obținut sau setat cu \texttt{session\_name()}.

Informația salvată \^in acest cookie, adică ID-ul, poate fi obținut cu
\texttt{session\_id()}.

\^Inainte de a lucra totuși cu sesiuni, trebuie să apelăm \texttt{session\_start()}.
Deoarece pornirea subsistemului PHP pentru sesiuni implică adăugarea unui header
'Set-Cookie', apelul la această funcție trebuie făcut \^inainte de a scrie orice
\^in \textit{response body}. Căci dacă am scris ceva \^in response body (de exemplu
cu \texttt{echo}), atunci \textit{response header}-ele sunt deja trimise, deci
e prea târziu să mai trimitem un cookie clientului.

Asta ne spune și eroarea din acest script:
\begin{lstlisting}[title=Headers already sent]
<?php
echo 'hello world';
session_start();
\end{lstlisting}
și anume
\begin{verbatim}
Warning: session_start(): Cannot send session cookie - headers already sent
\end{verbatim} 

După ce am pornit sesiunea, putem salva informații \^in array-ul superglobal
\texttt{\$\_SESSION}. Dar dacă informațiile nu vor fi salvate \^in cookie-ul
cu numele \texttt{session\_name()}, atunci unde vor fi salvate? Răspunsul:
\^in fișiere. Directiva php.ini \texttt{session.save\_path} ne spune unde se află
aceste fișiere. Fișierele vor fi numite după ID-ul sesiunii. Hai să vedem practic
cum funcționează acest mecanism:
\begin{lstlisting}[title=Understanding Sessions]
<?php
session_start();
$_SESSION['username'] = 'flav';
echo 'Datele salvate in $_SESSION se afla in fisierul: '.session_save_path().'/sess_'.session_id();
\end{lstlisting}

Deschiz\^and fișierul \^in care ne spune acest script că avem datele, vedem:
\begin{verbatim}
username|s:4:"flav";
\end{verbatim}
Ceea ce vedem aici sunt datele salvate \^in \texttt{\$\_SESSION}, numai că
sunt serializate \^in formatul specific modulului \textit{session}. Conceptul
de \textsl{serializare} \^insuși l-am cunoscut deja prin formatul json sau funcții
precum \texttt{serialize()} menționate anterior.

Funcția \texttt{session\_start()} nu face nimic altceva dec\^at să citească id-ul
din cookie-ul cu numele returnat de \texttt{session\_name()}\footnote{Care \^in mod
standard este 'PHPSESSID'.}, și să deserializeze informațiile aflate \^in fișierul
\texttt{session\_save\_path().'/sess\_'.session\_id()}
și să le salveze \^in
array-ul superglobal \texttt{\$\_SESSION}.

\subsection{Authentication}
A autentifica pe cineva nu înseamnă nimic mai mult decât a asocia
un identificator unic (un ID) cu un client (un browser), ID
care va fi salvat în două locuri: într-un cookie pe client, și pe
server, de obicei în numele fișierului din interiorul directorului
\texttt{session\_save\_path()}.

Deși repet, țin să subliniez încă o dată cât de \textit{fragilă} este această
autentificare: un simplu string de câteva zeci de caractere
(session ID) face diferența dintre a fi autentificat sau nu ... sau
a fi autentificat ca altcineva.

Dacă cineva reușește să facă rost de ID-ul unei sesiuni al unui
alt utilizator, e ca și autentificat ca acel utilizator.

Ți-ai putea imagina că a face rost de acest ID este ceva destul de
complicat, și că nu "oricine" ar putea face asta. Din fericire\footnote{"din
fericire" deoarece este încă un motiv în plus să acordăm o atenție
deosebită securității aplicațiilor noastre} pentru noi, acest lucru este
relativ trivial  -- în capitolul 5 vei vedea cum o singură greșeală
banală îi poate oferi atacatorului site-ului tău să injecteze cod HTML
și Javascript care să îi trimită acest ID\footnote{Atacul se numește
XSS - cross-site scripting}.

Pentru a face lucrurile mai dificile, o măsură adițională ar putea
fi identificarea și după adresa IP (\texttt{\$\_SERVER['REMOTE\_ADDR']}),
însă acest lucru are un dezavantaj: dacă îți aduci bine aminte din
capitolul \textit{Rețelistică}, mai mulți utilizatori care "împart"
accesul la Internet printr-un router au aceeași adresă IP publică.

Făcând autentificarea și\footnote{nu "doar", ci "și", conjunctiv: atât
după sesiune, cât și după IP} după adresa IP, aplicația ta ar putea
deveni "confuză" deoarece vede o singură adresă IP și mai multe
ID-uri de sesiune.

Adresa IP și ID-ul unic din cookie nu sunt însă singurele elemente
ce pot fi luate în considerare la autentificarea unui utilizator.
Majoritatea browserelor, numite și \textsl{agenți}, trimit un string
la fiecare cerere, pe care îl poți accesa prin \texttt{\$\_SERVER['HTTP\_USER\_AGENT']}.

\begin{Exercise}[title={O schemă de autentificare ieșită din comun},difficulty=2]
Extinde ``remote file storage'' cu autentificare.
Parola va fi acel ``<nume secret>'', iar fiecare ``nume
secret'' va avea un fișier \texttt{uploads/<nume secret>/users.csv}
ce va conține o listă de usernames. La crearea unui nou \texttt{<nume secret>},
proces numit "înregistrare" pe site-urile pe care le cunoști deja,
userul va trebui să uploadeze acel fișier \texttt{users.csv}. Nu vor exista
drepturi de acces, deci toată lumea va putea interzice accesul tuturor celorlalți
de \^indată ce are credentials \^in \texttt{users.csv}.
\end{Exercise}

\begin{Exercise}[title={Remote file storage cu galerie de imagini}]
Extinde aplicația de la exercițiul anterior astfel încât să detecteze
dacă un ``<nume secret>'' are doar imagini în el, și dacă
da, să afișeze acel director ca pe o galerie de imagini.
\end{Exercise}

\begin{Exercise}[title={Guestbook I},difficulty=2]
Crează un guestbook simplu, cu autentificarea unui singur
administrator. Intrările din guestbook trebuiesc salvate (serializate)
într-un format la alegere (json, csv, sau un format propriu), dar
nu trebuie să fie HTML.

Utilizatorii care vor să lase un mesaj vor introduce nume, adresă e-mail, un 
URL opțional și mesajul care poate conține doar tagurile HTML:
\texttt{<b>}, \texttt{<i>}, \texttt{<p>}.

Adițional, o linie goală poate delimita paragrafe.

Crează și o interfață de administrare, sistemul va avea un singur utilizator:
administratorul. Prin interfața de administrare acesta va putea șterge sau edita
intrările din guestbook sau bana adrese IP.
\end{Exercise}

\section{Felicitări}
În aceste capitole ai învățat să lucrezi cu conceptele fundamentale
din programare. Pe baza noțiunilor de rețelistică ai putut înțelege
diferiți vectori de atac, cum să îți protejezi aplicațiile împotriva
lor, cum poți autentifica și autoriza utilizatorii, și multe
alte posibilități prin intermediul funcțiilor puse la dispoziție de
PHP.

Ai învățat și cum îți poți modulariza codul astfel încât componente
precum \textit{business logic}, \textit{view logic} sau configurarea să fie
reutilizabile, eventual pe baza unor funcții proprii, care ar
trebui să fie la rândul lor la fel de reutilizabile.

Pentru a concepe toate aceste lucruri, ai învățat și cum să inventezi
structuri de date abstracte, pe care toate aceste
lucruri\footnote{business logic, view logic, funcțiile PHP și
funcțiile proprii} pot opera colectiv.

\begin{Exercise}[title={Recapitulare și sinteză}]
Citește cu atenție sinteza de mai sus, apoi închide cartea și scrie o
sinteză mai detaliată despre ce ai învățat în propriile cuvinte,
de cel puțin 300 de cuvinte.

Mult mai importantă dec\^at corectitudinea tehnică a rezumatului
este capacitatea ta de a jongla cu noțiunile, chiar și cu
riscul de a greși, deci nu te sfii să faci afirmații \^indrăznețe.
\end{Exercise}

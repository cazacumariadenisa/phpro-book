\chapter{Programare orientată pe obiecte}
\section{Principii OOP de bază}
\textsl{Programarea orientată pe obiecte} (en. \textsl{object-oriented programming}, abv. \textsl{OOP})
ne permite simularea realității folosind așa-numitele obiecte.

Aceste obiecte au \textsl{proprietăți} și \textsl{metode}. O pisică de exemplu poate avea
proprietățile \textit{nume}, \textit{vârstă}, \textit{culoare}, \textit{greutate}.

O metodă a unui obiect reprezintă o acțiune pe care o poate face acel obiect. O pisică
poate mieuna, mânca, dormi sau se uita pe fereastră. Pentru fiecare acțiune,
pisica noastră va avea o metodă.

PHP poate crea un obiect pe baza unui \textit{plan de construcție} numit \textsl{clasă}.
Deci înainte de a crea un obiect, trebuie să îi definim acest \textit{plan de construcție}.
Spunem că \textit{implementăm o clasă}, la fel cum spuneam și despre funcții
că le-am implementat.

Asta se face folosind cuvântul cheie \texttt{class}, iar în interiorul unui bloc înconjurat
de acolade (la fel ca o funcție) scriem definiția acelei clase.

Haideți să definim un posibil plan de construcție al unei pisici:

\begin{lstlisting}[title=An empty class]
<?php
class Cat {

}
$mycat = new Cat;
$hiscat = new Cat;
\end{lstlisting}

Liniile 2-4 definesc o nouă clasă numită \texttt{Cat}, iar această clasă este goală.
Pe liniile 5 și 6 creăm două obiecte de tip \texttt{Cat} și salvăm aceste obiecte
în variabilele \texttt{\$mycat} și respectiv \texttt{\$hiscat}.

Crearea de obiecte se face folosind cuvântul cheie \texttt{new} urmat de numele clasei.
Mai spunem și că am \textsl{instanțiat} clasa \texttt{Cat}.

Acest concept al instanțierii se potrivește cu ceea ce facem în viața reală:
de îndată ce ai planul de construcție al unei case, poți crea oricâte case
absolut identice. Toate casele vor avea aceleași facilități și aceleași
proprietăți cum sunt stabilite de arhitect în acel \textit{plan de construcție}
de pe hârtie.

Haideți să ne uităm mai întâi puțin la cum adăugăm proprietăți unui plan de construcție
și cum folosim aceste proprietăți după ce am creat instanțe concrete după acel plan.

\begin{lstlisting}[title=Public Class Properties]
<?php
class Cat {
  public $name;
  public $age;
  public $colour;
}

$mycat = new Cat;
\end{lstlisting}

Acum am adăugat trei proprietăți planului de construcție al clasei \texttt{Cat}. Toate
instanțele acestei clase vor avea aceste proprietăți. Nu vor exista pisici fără un
nume, o vârstă, și o culoare.

Aceste proprietăți sunt \textsl{publice}. Vom reveni mai târziu asupra acestui aspect,
însă ține minte: \texttt{public} este un specificator de acces (en. \textsl{access specifier})
care ne permite accesarea din exteriorul instanțelor a proprietăților sau metodelor pe 
care le califică.

Haideți să vedem ce înseamnă asta în cod, concret:
\begin{lstlisting}[firstnumber=9,title={Public Class Properties}]
$mycat->name = 'Cherry';
$mycat->age = 3;
$mycat->colour = 'black';

echo 'This is '.$mycat->name.', my kitty, it\'s '.$mycat->age.
  ' years old, and as you can see it\'s '.$mycat->colour.'.<br />';

$hiscat = new Cat;
echo 'His cat is called "',$hiscat->name,'"';
\end{lstlisting}

Cu operatorul \texttt{->} (en. \textsl{object operator}) accesăm
proprietățile\footnote{Mai târziu vom vedea că același operator este
folosit și pentru a apela metodele unui obiect} din interiorul unei instanțe.
Dacă acele proprietăți nu ar fi fost publice, nu le-am fi putut accesa din exterior
cu acest operator.

Pe linia 16 creăm o nouă instanță a acestei clase. După cum vezi, cele două pisici sunt complet
separate, fiecare cu proprietățile sale. De aceea, și pentru
că nu am inițializat nicăieri \texttt{\$hiscat->name}, aceasta este \texttt{NULL}.

\attention{Fiecare instanță a unei clase este independentă de celelalte instanțe, fie
ele și din aceeași clasă.}

Haideți să vedem ce se întâmplă atunci când o proprietate nu este publică.
Schimbă accesul proprietății \texttt{age} din \texttt{public}
în \texttt{private}. Vei vedea că nu mai poți accesa acea proprietate din exteriorul planului
de construcție (al clasei).

De fapt, este și de dorit ca proprietăți ca \texttt{age} să fie privată. După cum vezi,
aceste proprietăți pot fi suprascrise cu orice fel de informații. Însă fiecare proprietate
are specificul său. Proprietatea \texttt{age} de exemplu trebuie să fie mereu un număr pozitiv.

Dar cum setăm \texttt{age}, dacă proprietatea rămâne privată? Aici intervine al doilea lucru
pe care îl poate conține un astfel de \textit{plan de construcție}: \textsl{metodele}.

O metodă nu este nimic altceva decât o funcție. Însă implementarea acestei funcții se află
în interiorul definiției clasei, așa cum era de așteptat.

Deci haideți să introducem două metode noi pentru citirea din și scrierea în proprietatea
\texttt{age} a fiecărui obiect de tip \texttt{Cat}.

\begin{lstlisting}[title=Getters and Setters]
<?php
class Cat {
  private $name;
  private $age;
  private $colour;

  public function getAge() {
    return $this->age;
  }

  public function setAge($age) {
    if(is_numeric($age)) {
      $this->age = $age;
      return TRUE;
    }
    return FALSE;
  }
}

$mycat = new Cat;
var_dump($mycat->setAge('hello'));
var_dump($mycat->setAge(3));

echo 'My kitty is ',$mycat->getAge(),' years old.';
\end{lstlisting}

În interiorul unei clase avem acces la variabila \texttt{\$this} pe care
după cum vezi o și folosim în interiorul metodelor. Această variabilă
este creată atunci când fluxul de execuție ajunge pe linia 20, unde instanțiem
o clasă cu operatorul \texttt{new}. \texttt{\$this} face referire la același obiect la care face
referire și \texttt{\$mycat} în exteriorul clasei.

În interiorul clasei însă nu știm și nu ne pasă cum este numită variabila
în care salvăm această instanță în exterior (aici: \texttt{\$mycat}).
În \texttt{\$this} avem instanța curentă,
și prin ea, avem acces la toate metodele și proprietățile instanței.

Deoarece proprietatea \texttt{age} este privată, nu o putem accesa direct,
fie că vrem să salvăm ceva în ea, fie că vrem să citim din ea.

Din acest motiv, pe linia 21 apelăm metoda responsabilă pentru salvarea
de informații în \texttt{age}. Atunci când apelăm o metodă a unei instanțe,
mai spunem și că îi trimitem un mesaj acelei instanțe/obiect.

Deși obiectul primește acest mesaj pe care i-l transmitem, proprietatea
\texttt{age} nu este setată deoarece planul de construcție (implementarea clasei)
este în așa fel făcut încât nu acceptă decât numere.

În acest fel ne asigurăm că informațiile salvate în obiect sunt mereu valide,
indiferent de ce mesaje primim din exterior. Mai spunem și că astfel
impunem integritatea datelor.

Pe linia 24 apelăm metoda obiectului pentru citirea proprietății \texttt{age}.

După cum ți-ai dat seama, pentru fiecare proprietate pe care vrem să
o facem accesibilă cumva din exterior, dar în același timp să îi garatăm
integritatea, trebuie să creăm o pereche de astfel de două metode: una
pentru a salva date, alta pentru a primi date de la obiect.

La modul general, o metodă care setează valoarea unei proprietăți se numește
\textsl{setter}, iar o metodă care returnează valoarea unei proprietăți se
numește \textsl{getter}.

Bineînțeles că nu este musai ca o clasă să aibă câte o pereche
de getteri și setteri pentru fiecare proprietate.
E foarte posibil de exemplu să creăm o clasă care are doar setter pentru
o anumită proprietate, iar această clasă va funcționa ca un sac
fără fund, deoarece nu putem prelua informația din instanțe
de acel tip, ci doar {\glqq}pune în sac{\grqq}. Sau invers, doar
un getter, fără setter. Sau chiar o proprietate care nu este în
niciun fel expusă exteriorului.

\begin{Exercise}[title={A complete Kitty}]
\ExePart
Completează implementația clasei \texttt{Cat} cu getteri și setteri
pentru celelalte două proprietăți. Setterii trebuie să valideze
mesajele primite: un nume valid este constituit din doar un cuvânt
de lungime maximă 32 (de caractere), iar culoarea trebuie
să fie una din opt culori valide.

\ExePart
Adaugă o metodă care returnează o listă a tuturor culorilor pe
care le-a avut pisica de-a lungul timpului.
\end{Exercise}


Retrospectiv putem spune: o clasă este definiția unui nou tip de date
care înglobează proprietăți (informații salvate în variabile) și
metode (cod executabil sub formă de funcții) ce operează pe aceste
proprietăți.

%TODO constructor
%TODO self-containment (encapsulation): o clasă nu poate accesa proprietățile bicicletei adăpostite în ea, îi poate doar trimite mesaje
%TODO not a collection of methods, but a simulation of the real world

%TODO real world vs. application domain
%TODO sections for UML and design patterns

%TODO exerciţiu de echipă - unified process, agile, analysis and design, requirement analysis, application domain modelling, use cases,
%iterative design, implementation and unit-testing


% \section{AJAX. Studiu de caz: guestbook}
% introducere in javascript, firebug
% 
% jquery
% 
% \section{Temă: crearea unui blog}
% blog
% \section{Temă: crearea unui forum}
% Crearea unui forum
% 
